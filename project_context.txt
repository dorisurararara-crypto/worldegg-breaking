/*
================================================================================
PROJECT: EGG PONG (World Egg Breaking Game)
DESCRIPTION: A global multiplayer clicking game where users break an egg together.
BACKEND: Cloudflare Workers + Durable Objects + D1 Database
FRONTEND: React + Vite + Capacitor (Mobile Support)
================================================================================
*/

// --- FILE: egg-backend/src/gameDO.ts (Main Backend Logic) ---
/*
  This file contains the GameDO class, a Cloudflare Durable Object.
  It manages the global game state (HP, Round, Stats) and WebSocket connections.
  Key features: 
  - Real-time HP synchronization via WebSockets.
  - Tracking of highest attack (Max ATK), highest points, and highest clicks.
  - Anti-cheat/Rate limiting for clicks.
  - Winner determination (last hit) and email submission logic.
*/
[FILE_CONTENT_START:egg-backend/src/gameDO.ts]
import { DurableObject } from "cloudflare:workers";

interface GameState {
  hp: number;
  maxHp: number;
  round: number;
  status: 'PLAYING' | 'WINNER_CHECK' | 'FINISHED';
  winnerInfo: any;
  winnerCheckStartTime: number;
  winningClientId?: string; 
  winningToken?: string;    
  clicksByCountry: Record<string, number>;
  maxAtk: number;          // [Sync] Added
  maxAtkCountry: string;   // [Sync] Added
  maxPoints: number;       // [Sync] Added
  maxClicks: number;       // [Sync] Added
  announcement: string;
  prize: string;
  prizeUrl: string;
  adUrl: string;
  recentWinners: any[];
  rev: number;
  lastUpdatedAt: number;
}

interface PlayerSession {
  ws: WebSocket;
  ip: string;
  clientId: string;
  country: string;
  lastSeen: number;
  lastDeltaTime: number; 
  warnings?: number;     
  role: 'player' | 'spectator';
  queueToken?: string;
}

interface QueueItem {
  token: string;
  clientId: string;
  joinedAt: number;
  ws: WebSocket; 
}

export class GameDO extends DurableObject {
  state: DurableObjectState;
  env: any;
  
  // In-memory state
  gameState: GameState;
  
  // Connections
  sessions: Map<WebSocket, PlayerSession> = new Map(); 
  players: Map<string, PlayerSession> = new Map(); 
  
  queue: QueueItem[] = [];
  
  // Invite System
  pendingRewards: Map<string, number> = new Map();
  inviteCooldowns: Map<string, number> = new Map(); // Rate limiting (Memory only)
  
  // Constants
  MAX_PLAYERS = 1000;
  MAX_QUEUE = 1000; 
  BROADCAST_INTERVAL_MS = 2000; 
  SAVE_INTERVAL_MS = 20000; 
  
  // Loop Handles
  broadcastInterval: any = null;
  saveInterval: any = null;
  
  // Optimization
  lastBroadcastHp: number = -1;
  lastBroadcastTime: number = 0;
  lastBroadcastPlayers: number = -1;

  constructor(state: DurableObjectState, env: any) {
    super(state, env);
    this.state = state;
    this.env = env;

    this.gameState = {
      hp: 1000000,
      maxHp: 1000000,
      round: 1,
      status: 'PLAYING',
      winnerInfo: null,
      winnerCheckStartTime: 0,
      winningClientId: undefined,
      winningToken: undefined,
      clicksByCountry: {},
      maxAtk: 1,              // [Sync] Added
      maxAtkCountry: "UN",    // [Sync] Added
      maxPoints: 0,           // [Sync] Added
      maxClicks: 0,           // [Sync] Added
      announcement: "Welcome to Egg Pong!",
      prize: "Amazon Gift Card $50",
      prizeUrl: "https://amazon.com",
      adUrl: "",
      recentWinners: [],
      rev: 0,
      lastUpdatedAt: Date.now()
    };
    
    // Recovery
    this.state.blockConcurrencyWhile(async () => {
      const stored: any = await this.state.storage.get("fullState");
      if (stored) {
        this.gameState = { ...this.gameState, ...stored };
        // [Sync] Ensure defaults for new fields if missing in stored state
        this.gameState.maxAtk = this.gameState.maxAtk || 1;
        this.gameState.maxAtkCountry = this.gameState.maxAtkCountry || "UN";
        this.gameState.maxPoints = this.gameState.maxPoints || 0;
        this.gameState.maxClicks = this.gameState.maxClicks || 0;
      }
      
      const storedRewards: any = await this.state.storage.get("pendingRewards");
      if (storedRewards) {
          this.pendingRewards = storedRewards;
      }
      
      try {
          const { results } = await this.env.DB.prepare(
              "SELECT round, prize, created_at as date FROM winners ORDER BY id DESC LIMIT 5"
          ).all();
          
          if (results && Array.isArray(results)) {
              this.gameState.recentWinners = results;
          }
      } catch (e) {
          console.error("[Recovery] Failed to load winners:", e);
      }

      this.startLoops();
    });
  }

  startLoops() {
      if (!this.broadcastInterval) {
          this.broadcastInterval = setInterval(() => this.broadcastState(), this.BROADCAST_INTERVAL_MS);
      }
      if (!this.saveInterval) {
          this.saveInterval = setInterval(() => this.saveState(), this.SAVE_INTERVAL_MS);
      }
  }

  async fetch(request: Request) {
    const url = new URL(request.url);

    if (url.pathname === "/ws") {
      if (request.headers.get("Upgrade") !== "websocket") {
        return new Response("Expected Upgrade: websocket", { status: 426 });
      }
      
      const { 0: client, 1: server } = new WebSocketPair();
      const ip = request.headers.get("CF-Connecting-IP") || "unknown";
      const mode = url.searchParams.get("mode") || "spectator"; 
      
      this.handleSession(server, ip, mode);

      return new Response(null, { status: 101, webSocket: client });
    }

    if (url.pathname.startsWith("/admin/")) {
        return this.handleAdmin(request, url);
    }
    
    // --- Invite Reward API ---
    if (url.pathname === "/invite-reward" && request.method === "POST") {
        try {
            const body: any = await request.json();
            const { from, to } = body; 
            
            if (!from || !to || from === to) {
                return new Response(JSON.stringify({ success: false, error: "Invalid Request (Self or Empty)" }), { status: 400 });
            }

            // Memory Rate Limit (Optional)
            // const lastReq = this.inviteCooldowns.get(from);
            // if (lastReq && Date.now() - lastReq < 5000) { ... }
            
            // Use KST (UTC+9) for date
            const now = new Date();
            const kstDate = new Date(now.getTime() + 9 * 60 * 60 * 1000);
            const today = kstDate.toISOString().split('T')[0];
            
            const { results } = await this.env.DB.prepare(
                "SELECT (SELECT COUNT(*) FROM invites WHERE from_user = ? AND date = ?) as daily_count, (SELECT COUNT(*) FROM invites WHERE from_user = ? AND to_user = ?) as pair_exists"
            ).bind(from, today, from, to).all();
            
            const stats = results[0];
            
            if (stats.pair_exists > 0) {
                return new Response(JSON.stringify({ success: false, error: "Already invited this friend" }), { status: 400 });
            }
            if (stats.daily_count >= 5) {
                return new Response(JSON.stringify({ success: false, error: "Daily limit exceeded" }), { status: 400 });
            }
            
            try {
                await this.env.DB.prepare(
                    "INSERT INTO invites (from_user, to_user, date) VALUES (?, ?, ?)"
                ).bind(from, to, today).run();
            } catch (dbErr) {
                return new Response(JSON.stringify({ success: false, error: "Duplicate or DB Error" }), { status: 400 });
            }
            
            const reward = 800;
            let sent = false;
            
            for (const session of this.sessions.values()) {
                if (session.clientId === from) {
                    if (session.ws.readyState === WebSocket.OPEN) {
                        session.ws.send(JSON.stringify({
                            type: 'invite_reward',
                            amount: reward,
                            msg: "Friend joined! +800P" // [Sync] Updated text
                        }));
                        sent = true;
                    }
                    break;
                }
            }
            
            if (!sent) {
                const currentPending = this.pendingRewards.get(from) || 0;
                this.pendingRewards.set(from, currentPending + reward);
                await this.state.storage.put("pendingRewards", this.pendingRewards);
            }
            
            return new Response(JSON.stringify({ success: true, sent }), { status: 200 });

        } catch (e) {
            console.error("Invite Error:", e);
            return new Response(JSON.stringify({ error: "Internal Error" }), { status: 500 });
        }
    }
    
    if (url.pathname === "/winner" && request.method === "POST") {
      const body: any = await request.json();
      
      if (this.gameState.status !== 'WINNER_CHECK') {
          return new Response(JSON.stringify({ error: "Game not in winner check mode" }), { status: 400 });
      }
      if (!this.gameState.winningToken || body.token !== this.gameState.winningToken) {
          return new Response(JSON.stringify({ error: "Invalid winning token" }), { status: 403 });
      }
      
      try {
          await this.env.DB.prepare(
            "INSERT INTO winners (round, email, country, prize) VALUES (?, ?, ?, ?)"
          ).bind(this.gameState.round, body.email, body.country, this.gameState.prize).run();
      } catch (e) {}
      
      const maskedEmail = body.email.replace(/(^.{3}).+(@.+)/, "$1***$2");
      this.gameState.winnerInfo = { country: body.country, email: maskedEmail };
      this.gameState.status = 'FINISHED'; 
      
      this.gameState.winningClientId = undefined;
      this.gameState.winningToken = undefined;

      this.gameState.recentWinners.unshift({
          round: this.gameState.round,
          prize: this.gameState.prize,
          date: new Date().toISOString()
      });
      if (this.gameState.recentWinners.length > 5) this.gameState.recentWinners.pop();

      this.kickAllPlayers();

      this.gameState.lastUpdatedAt = Date.now();
      await this.saveState();
      this.broadcastState();

      return new Response(JSON.stringify({ success: true }));
    }
    
    if (url.pathname === "/state") {
        return new Response(JSON.stringify({
            ...this.gameState,
            onlinePlayers: this.players.size,
            onlineSpectatorsApprox: this.sessions.size - this.players.size,
            serverTs: Date.now()
        }), { headers: { "Content-Type": "application/json" }});
    }

    return new Response("Not Found", { status: 404 });
  }

  handleSession(ws: WebSocket, ip: string, requestedMode: string) {
    this.state.acceptWebSocket(ws);
  }

  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
    try {
      const msg = JSON.parse(typeof message === 'string' ? message : new TextDecoder().decode(message));
      
      if (msg.type === 'join') {
        const clientId = msg.clientId || crypto.randomUUID();
        const country = msg.country || "UN";
        
        if (this.gameState.status !== 'PLAYING') {
             ws.send(JSON.stringify({ type: 'error', code: 'ROUND_NOT_STARTED', message: 'Round not started yet.' }));
             ws.close(1008, "Round not started");
             return;
        }

        let role: 'player' | 'spectator' = 'spectator';
        let queuePos: number | null = null;
        let queueToken: string | undefined;

        if (this.sessions.has(ws)) {
            this.cleanupSession(ws); 
        }

        if (this.players.size < this.MAX_PLAYERS) {
            role = 'player';
            this.players.set(clientId, {
                ws, ip: "unknown", clientId, country, 
                lastSeen: Date.now(), lastDeltaTime: 0, role: 'player'
            });
        } else {
            if (this.queue.length < this.MAX_QUEUE) {
                role = 'spectator';
                queueToken = crypto.randomUUID();
                this.queue.push({ token: queueToken, clientId, joinedAt: Date.now(), ws });
                queuePos = this.queue.length;
            } else {
                ws.send(JSON.stringify({ type: 'error', code: "FULL", message: 'Server is full (Queue Max Reached)' }));
                ws.close(1008, "Server Full");
                return;
            }
        }

        const session: PlayerSession = {
            ws, ip: "unknown", clientId, country, 
            lastSeen: Date.now(), lastDeltaTime: 0, role, queueToken, warnings: 0
        };
        this.sessions.set(ws, session);

        ws.send(JSON.stringify({
            type: 'join_ok',
            role,
            queuePos,
            serverTs: Date.now(),
            buildId: "v1.0.0"
        }));
        
        const pending = this.pendingRewards.get(clientId);
        if (pending && pending > 0) {
            ws.send(JSON.stringify({
                type: 'invite_reward',
                amount: pending,
                msg: `Welcome back! You earned ${pending}P from invites.`
            }));
            this.pendingRewards.delete(clientId);
            this.state.storage.put("pendingRewards", this.pendingRewards);
        }

        this.sendStateTo(ws);
        return;
      }

      const session = this.sessions.get(ws);
      if (!session) return; 
      session.lastSeen = Date.now();

      if (msg.type === 'click_delta') {
          if (session.role !== 'player') {
              ws.send(JSON.stringify({ type: 'error', code: 'NOT_PLAYER', message: 'You are a spectator' }));
              return;
          }

          const now = Date.now();
          const timeSinceLast = now - session.lastDeltaTime;
          
          if (timeSinceLast < 4500) { 
              session.warnings = (session.warnings || 0) + 1;
              if (session.warnings > 3) {
                  try {
                      ws.send(JSON.stringify({ type: 'error', code: 'RATE_LIMIT_EXCEEDED', message: 'Kicked due to rate limit abuse.' }));
                      ws.close(1008, "Rate Limit Exceeded");
                  } catch(e) {}
                  return;
              }
              ws.send(JSON.stringify({ type: 'error', code: 'TOO_FAST', message: `Too fast! Wait ${Math.ceil((4500 - timeSinceLast) / 1000)}s` }));
              return; 
          }
          
          session.warnings = 0;
          session.lastDeltaTime = now;

          const delta = Number(msg.delta);
          const userAtk = Number(msg.atk || 1); // [Sync]
          const userPoints = Number(msg.points || 0);
          const userTotalClicks = Number(msg.totalClicks || 0);
          
          // console.log(`[DEBUG] Delta:${delta} Atk:${userAtk} Pts:${userPoints} Clicks:${userTotalClicks}`);

          if (isNaN(delta) || delta <= 0 || delta > 1000) { 
              ws.send(JSON.stringify({ type: 'error', code: 'BAD_DELTA', message: 'Invalid delta' }));
              return;
          }
          
          if (this.gameState.status === 'PLAYING' && this.gameState.hp > 0) {
              this.gameState.hp = Math.max(0, this.gameState.hp - delta);
              this.gameState.clicksByCountry[session.country] = (this.gameState.clicksByCountry[session.country] || 0) + delta;
              
              // [Sync] Max Atk Logic
              if (userAtk > this.gameState.maxAtk) {
                  this.gameState.maxAtk = userAtk;
                  this.gameState.maxAtkCountry = session.country;
              }
              
              // [Sync] Max Points & Clicks
              if (userPoints > this.gameState.maxPoints) {
                  this.gameState.maxPoints = userPoints;
              }
              if (userTotalClicks > this.gameState.maxClicks) {
                  this.gameState.maxClicks = userTotalClicks;
              }

              this.gameState.lastUpdatedAt = now;
              
              if (this.gameState.hp === 0) {
                  this.gameState.status = 'WINNER_CHECK';
                  this.gameState.winnerCheckStartTime = now;
                  this.gameState.winningClientId = session.clientId;
                  this.gameState.winningToken = crypto.randomUUID();

                  session.ws.send(JSON.stringify({
                      type: 'you_won',
                      token: this.gameState.winningToken,
                      round: this.gameState.round
                  }));
                  
                  this.saveState(); 
                  this.broadcastState(); 
              }
          }
      }
    } catch (e) {}
  }

  async webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean) {
      this.cleanupSession(ws);
  }
  
  async webSocketError(ws: WebSocket, error: any) {
      this.cleanupSession(ws);
  }

  cleanupSession(ws: WebSocket) {
      const session = this.sessions.get(ws);
      if (session) {
          if (session.role === 'player') {
              this.players.delete(session.clientId);
              this.promoteFromQueue(); 
          } else if (session.queueToken) {
              this.queue = this.queue.filter(q => q.token !== session.queueToken);
          }
          this.sessions.delete(ws);
      }
  }

  // [Fix] Removed Recursion
  promoteFromQueue() {
      while (this.queue.length > 0) {
          const next = this.queue.shift();
          if (!next) continue;
          
          const session = this.sessions.get(next.ws);
          if (session) {
              session.role = 'player';
              session.queueToken = undefined;
              this.players.set(session.clientId, session);
              
              if (next.ws.readyState === WebSocket.OPEN) {
                next.ws.send(JSON.stringify({
                    type: 'join_ok',
                    role: 'player',
                    queuePos: null,
                    serverTs: Date.now()
                }));
              }
              this.broadcastQueueUpdate();
              return; // Success, stop loop
          }
          // If session is gone, loop continues to next
      }
  }

  kickAllPlayers() {
      for (const p of this.players.values()) {
          try {
              p.ws.send(JSON.stringify({ type: 'error', code: 'GAME_OVER', message: 'Round finished. Thanks for playing!' })); // [Sync] Message
              p.ws.close(1000, "Round Finished");
          } catch(e) {}
      }
      this.players.clear();
  }

  broadcastQueueUpdate() {
      this.queue.forEach((item, idx) => {
          if (item.ws.readyState === WebSocket.OPEN) {
              item.ws.send(JSON.stringify({
                  type: 'queue_update',
                  queuePos: idx + 1,
                  etaSec: (idx + 1) * 30 
              }));
          }
      });
  }

  broadcastState() {
      if (this.sessions.size === 0) return;

      const now = Date.now();
      const hpChanged = this.gameState.hp !== this.lastBroadcastHp;
      const playersChanged = this.players.size !== this.lastBroadcastPlayers;
      const timeElapsed = now - this.lastBroadcastTime > 10000;
      const statusChanged = this.gameState.status !== 'PLAYING';

      if (!hpChanged && !playersChanged && !timeElapsed && !statusChanged) {
          return;
      }

      this.lastBroadcastHp = this.gameState.hp;
      this.lastBroadcastPlayers = this.players.size;
      this.lastBroadcastTime = now;

      const payload = JSON.stringify({
          type: 'state',
          hp: this.gameState.hp,
          maxHp: this.gameState.maxHp,
          round: this.gameState.round,
          status: this.gameState.status,
          winnerInfo: this.gameState.winnerInfo,
          winningClientId: this.gameState.winningClientId,
          onlinePlayers: this.players.size,
          onlineSpectatorsApprox: this.sessions.size - this.players.size,
          queueLength: this.queue.length, // [Sync]
          maxAtk: this.gameState.maxAtk, // [Sync]
          maxAtkCountry: this.gameState.maxAtkCountry, // [Sync]
          maxPoints: this.gameState.maxPoints,
          maxClicks: this.gameState.maxClicks,
          announcement: this.gameState.announcement,
          prize: this.gameState.prize,
          prizeUrl: this.gameState.prizeUrl,
          adUrl: this.gameState.adUrl,
          recentWinners: this.gameState.recentWinners, 
          rev: this.gameState.rev,
          lastUpdatedAt: this.gameState.lastUpdatedAt
      });
      for (const ws of this.sessions.keys()) {
          try { ws.send(payload); } catch(e) { this.cleanupSession(ws); }
      }
  }

  async saveState() {
      await this.state.storage.put("fullState", this.gameState);
  }

  async handleAdmin(request: Request, url: URL) {
      const authKey = request.headers.get("x-admin-key");
      if (authKey !== "egg1234") return new Response("Unauthorized", { status: 401 });
      
      const action = url.pathname.replace("/admin/", "");
      let details = "";
      const ip = request.headers.get("CF-Connecting-IP") || "unknown";

      if (action === "reset-round") {
          this.gameState.hp = 1000000;
          this.gameState.round += 1;
          this.gameState.clicksByCountry = {};
          this.gameState.maxAtk = 1; // [Sync]
          this.gameState.maxAtkCountry = "UN"; // [Sync]
          this.gameState.maxPoints = 0;
          this.gameState.maxClicks = 0;
          this.gameState.status = 'PLAYING';
          this.gameState.winnerInfo = null;
          this.gameState.lastUpdatedAt = Date.now();
          
          // Clear invites table for the new round
          let clearMsg = "";
          try {
              // Simply try to delete. If table missing, it will throw, which is fine (we catch it).
              const { meta } = await this.env.DB.prepare("DELETE FROM invites").run();
              clearMsg = ` (Invites cleared: ${meta.changes || 0} rows)`;
          } catch (e) {
              console.error("Failed to clear invites:", e);
              // If delete fails, try creating table ONLY if needed, with simple schema
              try {
                  await this.env.DB.prepare("CREATE TABLE IF NOT EXISTS invites (id INTEGER PRIMARY KEY, from_user TEXT, to_user TEXT, date TEXT)").run();
                  const { meta } = await this.env.DB.prepare("DELETE FROM invites").run();
                  clearMsg = ` (Invites table created & cleared: ${meta.changes || 0} rows)`;
              } catch (e2) {
                  clearMsg = ` (Invites clear FAILED: ${e.message})`;
              }
          }
          
          // Promote all possible players
          while (this.players.size < this.MAX_PLAYERS && this.queue.length > 0) {
              this.promoteFromQueue();
          }
          
          details = `Reset Round to ${this.gameState.round}${clearMsg}`;
          await this.saveState();
          this.broadcastState();

      } else if (action === "set-round" && request.method === "POST") {
          const body: any = await request.json();
          this.gameState.round = body.round;
          this.gameState.lastUpdatedAt = Date.now();
          details = `Set Round to ${body.round}`;
          await this.saveState();
          this.broadcastState();

      } else if (action === "set-hp" && request.method === "POST") {
          const body: any = await request.json();
          this.gameState.hp = body.hp;
          this.gameState.status = 'PLAYING';
          this.gameState.winnerInfo = null;
          this.gameState.lastUpdatedAt = Date.now();
          details = `Set HP to ${body.hp}`;
          await this.saveState();
          this.broadcastState();

      } else if (action === "config" && request.method === "POST") {
          const body: any = await request.json();
          if (body.announcement !== undefined) this.gameState.announcement = body.announcement;
          if (body.prize !== undefined) this.gameState.prize = body.prize;
          if (body.prizeUrl !== undefined) this.gameState.prizeUrl = body.prizeUrl;
          if (body.adUrl !== undefined) this.gameState.adUrl = body.adUrl;
          this.gameState.lastUpdatedAt = Date.now();
          details = `Config Updated`;
          await this.saveState();
          this.broadcastState();

      } else if (action === "winners" && request.method === "GET") {
          try {
              const { results } = await this.env.DB.prepare("SELECT * FROM winners ORDER BY id DESC LIMIT 50").all();
              return new Response(JSON.stringify(results));
          } catch(e) {
              return new Response(JSON.stringify([]));
          }

      } else if (action.startsWith("winners/") && request.method === "DELETE") {
          const id = action.split("/")[1];
          if (!id) return new Response("Missing ID", { status: 400 });
          try {
              await this.env.DB.prepare("DELETE FROM winners WHERE id = ?").bind(id).run();
              details = `Deleted winner ID ${id}`;
              // Refresh recent winners cache
              const { results } = await this.env.DB.prepare(
                  "SELECT round, prize, created_at as date FROM winners ORDER BY id DESC LIMIT 5"
              ).all();
              if (results) this.gameState.recentWinners = results;
              this.broadcastState();
          } catch(e) {
              return new Response("DB Error: " + e, { status: 500 });
          }
      }
      
      // [Sync] Audit Log
      if (details) {
          try {
              await this.env.DB.prepare("INSERT INTO audit_logs (action, details, ip) VALUES (?, ?, ?)").bind(action, details, ip).run();
          } catch(e) {}
      }

      return new Response(JSON.stringify({ success: true, details })); // details ì¶”ê°€
  }
  
  sendStateTo(ws: WebSocket) {
      ws.send(JSON.stringify({
          type: 'state',
          hp: this.gameState.hp,
          maxHp: this.gameState.maxHp,
          round: this.gameState.round,
          status: this.gameState.status,
          winnerInfo: this.gameState.winnerInfo,
          winningClientId: this.gameState.winningClientId,
          onlinePlayers: this.players.size,
          onlineSpectatorsApprox: this.sessions.size - this.players.size,
          queueLength: this.queue.length,
          maxAtk: this.gameState.maxAtk,
          maxAtkCountry: this.gameState.maxAtkCountry,
          maxPoints: this.gameState.maxPoints,
          maxClicks: this.gameState.maxClicks,
          announcement: this.gameState.announcement,
          prize: this.gameState.prize,
          prizeUrl: this.gameState.prizeUrl,
          adUrl: this.gameState.adUrl,
          recentWinners: this.gameState.recentWinners,
          rev: this.gameState.rev,
          lastUpdatedAt: this.gameState.lastUpdatedAt
      }));
  }
}
[FILE_CONTENT_END:egg-backend/src/gameDO.ts]

// --- FILE: egg-backend/src/index.ts (Backend Entry Point) ---
/*
  The main entry point for the Cloudflare Worker. 
  It handles HTTP requests, routes them to the GameDO, and manages CORS and WebSocket upgrades.
*/
[FILE_CONTENT_START:egg-backend/src/index.ts]
import { GameDO } from "./gameDO";
export { GameDO };

export default {
  async fetch(request: Request, env: any) {
    const url = new URL(request.url);
    
    // CORS configuration
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, x-admin-key",
    };

    if (request.method === "OPTIONS") {
      return new Response(null, { headers: corsHeaders });
    }

    // Global Single Instance
    const id = env.GAME_DO.idFromName("GLOBAL_EGG_ID");
    const stub = env.GAME_DO.get(id);

    // Helper to proxy requests to DO
    const proxyToDo = async (targetPath: string) => {
        const newReq = new Request(url.origin + targetPath + url.search, request);
        return stub.fetch(newReq);
    };

    // WebSocket Upgrade Check
    if (request.headers.get("Upgrade") === "websocket") {
        // Handle /ws or /api/ws
        if (url.pathname === "/ws" || url.pathname === "/api/ws") {
            return proxyToDo("/ws");
        }
    }

    // WebSocket Direct Path
    if (url.pathname === "/ws") {
        return stub.fetch(request);
    }

    // HTTP API Routing
    if (url.pathname.startsWith("/api/") || url.pathname.startsWith("/admin/") || url.pathname.startsWith("/invite-reward")) {
      const doPath = url.pathname.replace("/api", "");
      
      const newReq = new Request(url.origin + doPath, request);
      const response = await stub.fetch(newReq);
      
      // If it's a websocket response (101), return it directly
      if (response.status === 101) {
          return response;
      }

      const newHeaders = new Headers(response.headers);
      Object.entries(corsHeaders).forEach(([k, v]) => newHeaders.set(k, v));
      newHeaders.set("Cache-Control", "no-store");

      return new Response(response.body, {
        status: response.status,
        headers: newHeaders
      });
    }

    return new Response("Not Found", { status: 404, headers: corsHeaders });
  }
};
[FILE_CONTENT_END:egg-backend/src/index.ts]

// --- FILE: egg-breaker/src/App.jsx (Main Frontend Component) ---
/*
  The core React component. It manages:
  - Multi-language support (KR, US, JP, CN).
  - Main game loop and local state (Points, ATK, Tools).
  - Synchronization between local HP and Server HP.
  - Event handlers for clicking, buying items, and watching ads.
*/
[FILE_CONTENT_START:egg-breaker/src/App.jsx]
import { useState, useEffect, useRef } from 'react';
import { NativeAudio } from '@capacitor-community/native-audio';
import { Capacitor } from '@capacitor/core';
import { useGameState } from './hooks/useGameState';
import { usePushNotifications } from './hooks/usePushNotifications';
import './App.css';
import Admin from './Admin';
import Header from './components/Header';
import LeftPanel from './components/LeftPanel';
import RightPanel from './components/RightPanel';
import InfoPanel from './components/InfoPanel';
import GameArea from './components/GameArea';

// (Translations and TOOL_NAMES omitted for brevity in summary, but logical structure follows)
// ... [Full Code follows below]
[FILE_CONTENT_START:egg-breaker/src/App.jsx]
import { useState, useEffect, useRef } from 'react';
import { NativeAudio } from '@capacitor-community/native-audio';
import { Capacitor } from '@capacitor/core';
import { useGameState } from './hooks/useGameState';
import { usePushNotifications } from './hooks/usePushNotifications';
import './App.css';
import Admin from './Admin';
import Header from './components/Header';
import LeftPanel from './components/LeftPanel';
import RightPanel from './components/RightPanel';
import InfoPanel from './components/InfoPanel';
import GameArea from './components/GameArea';

// --- ë‹¤êµ­ì–´ ë°ì´í„° (ìœ ì§€) ---
const TRANSLATIONS = {
  US: { 
    label: "English", title: "Egg Pong â˜ï¸", subtitle: "Pop! Let's crack this egg together!", users: "Live Users", total: "Total", shop: "Shop", myPoint: "Points", atk: "ATK", item1: "Dual Hammer", item2: "Pickaxe", item3: "TNT", item4: "Drill", item5: "Excavator", item6: "Laser Gun", item7: "Nuclear Bomb", modalTitle: "ðŸŽ‰ Congratulations! ðŸŽ‰", modalDesc: "You delivered the final blow and broke the egg! You are the Legendary Destroyer.", modalPrize: "Please enter your email address to receive the prize:", send: "Submit to Claim Prize", adText: "Ad Banner Area", powerClick: "âš¡ Power Click (+100) âš¡", watchAd: "Watch an Ad", logo: "Egg Pong â˜ï¸",
    gameRuleTitle: "How to Play", gameRule1: "- Click the egg to reduce its HP.", gameRule2: "- Collect points to buy items. The stronger you get, the greater the rewards!", gameRule3: "- Break the egg with the world!", noticeTitle: "Notice", notice1: "- Abnormal play may result in a ban.", notice2: "- This game may be reset.", prizeTitle: "Current Prize", contactTitle: "Contact", myInfoTitle: "My Info", totalClick: "Total Clicks",
    notEnoughPoints: "Points not enough!", alreadyShared: "You already received the share reward for this round!", shareSuccess: "Link shared! You will get 800P when your friend plays.", inviteSuccess: "Friend joined! You got 800 Points!", sent: "Sent successfully!", bought: "Bought",
    newRoundReset: "New Round Started! All progress has been reset.",
    shopGuide: "Click the shop on the right to get powerful items!",
    rivalryTitle: "TOP RIVALRY", gap: "Gap", waiting: "Waiting...", noRival: "No Rival",
    hallOfFame: "Menu", recentPrizes: "Recent Prizes", noRecords: "No records yet. Be the first winner!",
    adWatchBtn: "ðŸ“º Watch Ad (+2000P)", shareBtn: "ðŸ’¬ Share (+800P)",
    adReward: "+2000 Points", shareReward: "Share & Get 800P (Max 5)",
    roundOverTitle: "Round Over!", roundOverDesc: "Waiting for the next round to begin.",
    checkingWinnerTitle: "Checking Winner...", checkingWinnerDesc: "Please wait while we verify the legendary destroyer.",
    winnerTimerWarning: "You must enter your email within 5 minutes.", winnerExitMsg: "Sent! Exiting... (Opening new window)", loserMsg: "Unfortunately, you failed. Exiting... (Opening new window)", timeLeft: "Time Left",
    retryTitle: "Ready to try again?", retryBtn: "ðŸ”„ Re-enter Game",
    tapToClose: "(Tap to close)",
    maxAtkTitle: "Highest Attack", maxPointTitle: "Highest Points", maxClickTitle: "Highest Clicks", serverStatusTitle: "Server Status", participants: "Active", queueLabel: "Queue", spectators: "Spectators", totalOnline: "Total Online"
  },
  KR: { 
    label: "í•œêµ­ì–´", title: "ì—ê·¸í â˜ï¸", subtitle: "ë‹¤í•¨ê»˜ í! ì „ì„¤ì˜ ì•Œ ê¹¨ê¸°", users: "ì ‘ì†ìž", total: "ì´", shop: "ìƒì ", myPoint: "ë³´ìœ  í¬ì¸íŠ¸", atk: "ê³µê²©ë ¥", item1: "ìŒë§ì¹˜", item2: "ê³¡ê´­ì´", item3: "TNT í­ì•½", item4: "ë“œë¦´", item5: "í¬í¬ë ˆì¸", item6: "ë ˆì´ì € ì´", item7: "í•µí­íƒ„", modalTitle: "ðŸŽ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ðŸŽ‰", modalDesc: "ë§ˆì§€ë§‰ ì¼ê²©ì„ ê°€í•´ ì•Œì„ ê¹¨íŠ¸ë¦¬ì…¨ìŠµë‹ˆë‹¤! ë‹¹ì‹ ì´ ë°”ë¡œ ì „ì„¤ì˜ íŒŒê´´ìžìž…ë‹ˆë‹¤.", modalPrize: "ìƒí’ˆ ìˆ˜ë ¹ì„ ìœ„í•´ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ìž…ë ¥í•´ì£¼ì„¸ìš”(ìƒˆë¡œê³ ì¹¨ì„ ëˆ„ë¥´ì§€ ë§ˆì„¸ìš”! ì´ˆê¸°í™”ë©ë‹ˆë‹¤.):", send: "ìƒí’ˆ ì‹ ì²­í•˜ê¸°", adText: "ê´‘ê³  ì˜ì—­", powerClick: "âš¡ íŒŒì›Œ í´ë¦­ (+100) âš¡", watchAd: "ê´‘ê³  ë³´ê³  ", logo: "ì—ê·¸í â˜ï¸",
    gameRuleTitle: "ê²Œìž„ ë°©ë²•", gameRule1: "- í™”ë©´ì„ í´ë¦­í•˜ì—¬ ì•Œì˜ HPë¥¼ ì¤„ì´ì„¸ìš”.", gameRule2: "- í¬ì¸íŠ¸ë¥¼ ëª¨ì•„ ì•„ì´í…œì„ êµ¬ë§¤í•˜ë©´ ê³µê²©ë ¥ì´ ì˜¬ë¼ê°‘ë‹ˆë‹¤.", gameRule3: "- ë§ˆì§€ë§‰ ì¼ê²©ì„ ê°€í•œ ë‹¨ í•œ ëª…ì´ ìš°ìŠ¹ ìƒí’ˆì„ ì°¨ì§€í•©ë‹ˆë‹¤!", noticeTitle: "ì£¼ì˜ì‚¬í•­", notice1: "- ë¹„ì •ìƒì ì¸ í”Œë ˆì´ëŠ” ì œìž¬ë  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.", notice2: "- ìƒˆë¡œê³ ì¹¨ ì‹œ ì´ˆê¸°í™”ë  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.", prizeTitle: "ì´ë²ˆ íšŒì°¨ ìƒí’ˆ", contactTitle: "ì œíœ´ë¬¸ì˜", myInfoTitle: "ë‚´ ì •ë³´", totalClick: "ì´ í´ë¦­",
    notEnoughPoints: "í¬ì¸íŠ¸ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!", alreadyShared: "ì´ë²ˆ ë¼ìš´ë“œì—ëŠ” ì´ë¯¸ ê³µìœ  ë³´ìƒì„ ë°›ìœ¼ì…¨ìŠµë‹ˆë‹¤!", shareSuccess: "ë§í¬ ê³µìœ  ì™„ë£Œ! ì¹œêµ¬ê°€ ì ‘ì†í•˜ë©´ 800Pê°€ ì§€ê¸‰ë©ë‹ˆë‹¤.", inviteSuccess: "ì¹œêµ¬ê°€ ì ‘ì†í–ˆìŠµë‹ˆë‹¤! 800 í¬ì¸íŠ¸ë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!", sent: "ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤!", bought: "êµ¬ë§¤ ì™„ë£Œ:",
    newRoundReset: "ìƒˆë¡œìš´ ë¼ìš´ë“œê°€ ì‹œìž‘ë˜ì—ˆìŠµë‹ˆë‹¤! ëª¨ë“  ì§„í–‰ ìƒí™©ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.",
    shopGuide: "ì—¬ê¸°ë¥¼ ëˆŒëŸ¬ ë” ê°•ë ¥í•œ ì•„ì´í…œì„ íšë“í•˜ì„¸ìš”",
    rivalryTitle: "êµ­ê°€ ëŒ€í•­ì „", gap: "ì°¨ì´", waiting: "ëŒ€ê¸°ì¤‘...", noRival: "ë¼ì´ë²Œ ì—†ìŒ",
    hallOfFame: "ìƒí’ˆ", recentPrizes: "ìµœê·¼ ìš°ìŠ¹ ìƒí’ˆ", noRecords: "ì•„ì§ ìš°ìŠ¹ìžê°€ ì—†ìŠµë‹ˆë‹¤. ì²« ìš°ìŠ¹ìžê°€ ë˜ì–´ë³´ì„¸ìš”!",
    adWatchBtn: "ðŸ“º ê´‘ê³  ë³´ê³  í¬ì¸íŠ¸ ë°›ê¸°(+2000P)", shareBtn: "ðŸ’¬ ê³µìœ í•˜ê¸° (+800P)",
    adReward: "", shareReward: "ì¹´í†¡ìœ¼ë¡œ ê³µìœ í•˜ê³  800P ë°›ê¸° (ìµœëŒ€ 5íšŒ)",
    roundOverTitle: "ë¼ìš´ë“œ ì¢…ë£Œ!", roundOverDesc: "ë‹¤ìŒ ë¼ìš´ë“œ ì¤€ë¹„ ì¤‘ìž…ë‹ˆë‹¤.",
    checkingWinnerTitle: "ìš°ìŠ¹ìž íŒë… ì¤‘...", checkingWinnerDesc: "ëˆ„ê°€ ë§ˆì§€ë§‰ ì¼ê²©ì„ ë‚ ë ¸ëŠ”ì§€ í™•ì¸í•˜ê³  ìžˆìŠµë‹ˆë‹¤.",
    winnerTimerWarning: "5ë¶„ ì•ˆì— ì´ë©”ì¼ì„ ìž…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤. (ë¯¸ìž…ë ¥ ì‹œ ì·¨ì†Œ)", winnerExitMsg: "ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤! ìž ì‹œ í›„ í‡´ìž¥í•©ë‹ˆë‹¤", loserMsg: "ì•„ì‰½ê²Œë„ ì´ë²ˆì—ëŠ” ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìž ì‹œ í›„ í‡´ìž¥í•©ë‹ˆë‹¤ (ìƒˆ ì°½ ì—´ë¦¼)", timeLeft: "ë‚¨ì€ ì‹œê°„",
    retryTitle: "ë‹¤ì‹œ ë„ì „í•˜ì‹œê² ìŠµë‹ˆê¹Œ?", retryBtn: "ðŸ”„ ìž¬ìž…ìž¥í•˜ê¸°",
    tapToClose: "(íƒ­í•˜ì—¬ ì—†ì• ê¸°)",
    maxAtkTitle: "ìµœê³  ê³µê²©ë ¥", maxPointTitle: "ìµœê³  í¬ì¸íŠ¸", maxClickTitle: "ìµœê³  í´ë¦­ìˆ˜", serverStatusTitle: "ì„œë²„ í˜„í™©", participants: "ì°¸ì—¬ìž", queueLabel: "ëŒ€ê¸°ìž", spectators: "êµ¬ê²½ê¾¼", totalOnline: "Total Online"
  },
  JP: { 
    label: "æ—¥æœ¬èªž", title: "ã‚¨ãƒƒã‚°ãƒãƒ³ â˜ï¸", subtitle: "ä¸–ç•Œä¸­ã§ä¼èª¬ã®åµã‚’å‰²ã‚ã†", users: "æŽ¥ç¶šä¸­", total: "è¨ˆ", shop: "å•†åº—", myPoint: "ãƒã‚¤ãƒ³ãƒˆ", atk: "æ”»æ’ƒåŠ›", item1: "ãƒãƒ³ãƒžãƒ¼", item2: "ã¤ã‚‹ã¯ã—", item3: "ãƒ€ã‚¤ãƒŠãƒžã‚¤ãƒˆ", item4: "ãƒ‰ãƒªãƒ«", item5: "ã‚·ãƒ§ãƒ™ãƒ«ã‚«ãƒ¼", item6: "ãƒ¬ãƒ¼ã‚¶ãƒ¼éŠƒ", item7: "æ ¸çˆ†å¼¾", modalTitle: "ðŸŽ‰ ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼ ðŸŽ‰", modalDesc: "æœ€å¾Œã®ä¸€æ’ƒã§åµã‚’å‰²ã‚Šã¾ã—ãŸï¼ã‚ãªãŸãŒä¼èª¬ã®ç ´å£Šè€…ã§ã™ã€‚", modalPrize: "è³žå“ã‚’å—ã‘å–ã‚‹ãŸã‚ã«ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š", send: "é€ä¿¡ã™ã‚‹", adText: "åºƒå‘Šã‚¨ãƒªã‚¢", powerClick: "âš¡ ãƒ‘ãƒ¯ãƒ¼ã‚¯ãƒªãƒƒã‚¯ (+100) âš¡", watchAd: "åºƒå‘Šã‚’è¦‹ã¦æ”»æ’ƒ", logo: "ã‚¨ãƒƒã‚°ãƒãƒ³ â˜ï¸",
    gameRuleTitle: "éŠã³æ–¹", gameRule1: "- åµã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦HPë¥¼æ¸›ã‚‰ã—ã¦ãã ã•ã„ã€‚", gameRule2: "- ãƒã‚¤ãƒ³ãƒˆã‚’é›†ã‚ã¦ã‚¢ã‚¤ãƒ†ãƒ ã‚’è³¼å…¥ã—ã¾ã—ã‚‡ã†ã€‚", gameRule3: "- ä¸–ç•Œä¸­ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨ä¸€ç·’ã«åµã‚’å‰²ã‚Šã¾ã—ã‚‡ã†ï¼", noticeTitle: "æ³¨æ„äº‹é …", notice1: "- ä¸æ­£ãªãƒ—ãƒ¬ã‚¤ã¯åˆ¶è£ã®å¯¾è±¡ã¨ãªã‚Šã¾ã™ã€‚", notice2: "- ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã¯ãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚", prizeTitle: "ä»Šå›žã®è³žå“", contactTitle: "ãŠå•ã„åˆã‚ã›", myInfoTitle: "ãƒžã‚¤æƒ…å ±", totalClick: "ç·ã‚¯ãƒªãƒƒã‚¯æ•°",
    notEnoughPoints: "ãƒã‚¤ãƒ³ãƒˆãŒè¶³ã‚Šã¾ã›ã‚“ï¼", alreadyShared: "ã“ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã®ã‚·ã‚§ã‚¢å ±é…¬ã¯æ—¢ã«å—ã‘å–ã£ã¦ã„ã¾ã™ï¼", shareSuccess: "ãƒªãƒ³ã‚¯ã‚’ã‚·ã‚§ã‚¢ã—ã¾ã—ãŸï¼å‹é”ãŒå‚åŠ ã™ã‚‹ã¨800Pã‚‚ã‚‰ãˆã¾ã™ã€‚", inviteSuccess: "å‹é”ãŒå‚åŠ ã—ã¾ã—ãŸï¼800ãƒã‚¤ãƒ³ãƒˆã‚’ç²å¾—ã—ã¾ã—ãŸï¼", sent: "é€ä¿¡ã—ã¾ã—ãŸï¼", bought: "è³¼å…¥å®Œäº†:",
    newRoundReset: "æ–°ã—ã„ãƒ©ã‚¦ãƒ³ãƒ‰ãŒå§‹ã¾ã‚Šã¾ã—ãŸï¼ã™ã¹ã¦ã®é€²è¡ŒçŠ¶æ³ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸã€‚",
    shopGuide: "å³ã®ã‚·ãƒ§ãƒƒãƒ—ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å¼·åŠ›ãªã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‰‹ã«å…¥ã‚Œã‚ˆã†ï¼",
    rivalryTitle: "å›½å®¶å¯¾æŠ—æˆ¦", gap: "å·®", waiting: "å¾…æ©Ÿä¸­...", noRival: "ãƒ©ã‚¤ãƒãƒ«ãªã—",
    hallOfFame: "ãƒ¡ãƒ‹ãƒ¥ãƒ¼", recentPrizes: "æœ€è¿‘ã®è³žå“", noRecords: "ã¾ã å‹è€…ã¯ã„ã¾ã›ã‚“ã€‚æœ€åˆã®å‹è€…ã«ãªã‚ã†ï¼",
    adWatchBtn: "ðŸ“º åºƒå‘Šã‚’è¦‹ã‚‹ (+2000P)", shareBtn: "ðŸ’¬ ã‚·ã‚§ã‚¢ (+800P)",
    adReward: "+2000 ãƒã‚¤ãƒ³ãƒˆ", shareReward: "ã‚·ã‚§ã‚¢ã—ã¦800Pã‚²ãƒƒãƒˆ (æœ€å¤§5å›ž)",
    roundOverTitle: "ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†ï¼", roundOverDesc: "æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’å¾…æ©Ÿä¸­...",
    checkingWinnerTitle: "å‹è€…ã‚’åˆ¤å®šä¸­...", checkingWinnerDesc: "ä¼èª¬ã®ç ´å£Šè€…ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚",
    winnerTimerWarning: "5ë¶„ ì´ë‚´ì— ìž…ë ¥í•´ì£¼ì„¸ìš”ã€‚", winnerExitMsg: "é€ä¿¡ã—ã¾ã—ãŸï¼ã¾ã‚‚ãªãçµ‚äº†ã—ã¾ã™ (æ–°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦)", loserMsg: "æ®‹å¿µãªãŒã‚‰å¤±æ•—ã—ã¾ã—ãŸã€‚ã¾ã‚‚ãªãçµ‚äº†ã—ã¾ã™ (æ–°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦)", timeLeft: "æ®‹ã‚Šæ™‚é–“",
    retryTitle: "ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã—ã¾ã™ã‹ï¼Ÿ", retryBtn: "ðŸ”„ ã‚²ãƒ¼ãƒ å†å…¥å ´",
    tapToClose: "(ã‚¿ãƒƒãƒ—ã—ã¦é–‰ã˜ã‚‹)",
    maxAtkTitle: "æœ€é«˜æ”»æ’ƒåŠ›", maxPointTitle: "æœ€é«˜ãƒã‚¤ãƒ³ãƒˆ", maxClickTitle: "æœ€é«˜ã‚¯ãƒªãƒƒã‚¯æ•°", serverStatusTitle: "ã‚µãƒ¼ãƒãƒ¼çŠ¶æ³", participants: "å‚åŠ è€…", queueLabel: "å¾…æ©Ÿä¸­", spectators: "è¦³æˆ¦è€…", totalOnline: "Total Online"
  },
  CN: { 
    label: "ä¸­æ–‡", title: "è›‹è›‹ç¢° â˜ï¸", subtitle: "å…¨ä¸–ç•Œä¸€èµ·å‡»ç¢Žä¼ è¯´ä¹‹è›‹", users: "åœ¨çº¿", total: "æ€»è®¡", shop: "å•†åº—", myPoint: "ç§¯åˆ†", atk: "æ”»å‡»åŠ›", item1: "åŒé”¤", item2: "é’¢é•", item3: "ç‚¸è¯", item4: "é’»å¤´", item5: "æŒ–æŽ˜æœº", item6: "æ¿€å…‰æžª", item7: "æ ¸å¼¹", modalTitle: "ðŸŽ‰ æ­å–œï¼ ðŸŽ‰", modalDesc: "æ‚¨å®Œæˆäº†æœ€åŽä¸€å‡»ï¼Œå‡»ç¢Žäº†é¸¡è›‹ï¼æ‚¨å°±æ˜¯ä¼ è¯´ä¸­çš„ç ´åè€…ã€‚", modalPrize: "è¯·è¾“å…¥æ‚¨çš„ç”µå­é‚®ç®±ä»¥é¢†å–å¥–å“ï¼š", send: "æäº¤é¢†å¥–", adText: "å¹¿å‘ŠåŒºåŸŸ", powerClick: "âš¡ è¶…çº§ç‚¹å‡» (+100) âš¡", watchAd: "çœ‹å¹¿å‘Šå¼ºåŠ›æ”»å‡»", logo: "è›‹è›‹ç¢° â˜ï¸",
    gameRuleTitle: "æ¸¸æˆçŽ©æ³•", gameRule1: "- ç‚¹å‡»è›‹ä»¥å‡å°‘å…¶HPã€‚", gameRule2: "- æ”¶é›†ç§¯åˆ†è´­ä¹°é“å…·ã€‚", gameRule3: "- ä¸Žå…¨ä¸–ç•Œçš„çŽ©å®¶ä¸€èµ·å‡»ç¢Žè›‹ï¼", noticeTitle: "æ³¨æ„äº‹é¡¹", notice1: "- å¼‚å¸¸æ¸¸æˆè¡Œä¸ºå¯èƒ½ä¼šè¢«å°ç¦ã€‚", notice2: "- æœ¬æ¸¸æˆå¯èƒ½ä¼šè¢«é‡ç½®ã€‚", prizeTitle: "æœ¬æœŸå¥–å“", contactTitle: "å•†åŠ¡åˆä½œ", myInfoTitle: "æˆ‘çš„ä¿¡æ¯", totalClick: "æ€»ç‚¹å‡»æ•°",
    notEnoughPoints: "ç§¯åˆ†ä¸è¶³ï¼", alreadyShared: "æœ¬è½®å·²é¢†å–åˆ†äº«å¥–åŠ±ï¼", shareSuccess: "é“¾æŽ¥å·²åˆ†äº«ï¼å¥½å‹è¿›å…¥æ¸¸æˆæ—¶æ‚¨å°†èŽ·å¾—800ç§¯åˆ†ã€‚", inviteSuccess: "å¥½å‹å·²åŠ å…¥ï¼èŽ·å¾—800ç§¯åˆ†ï¼", sent: "å·²å‘é€ï¼", bought: "è´­ä¹°æˆåŠŸ:",
    newRoundReset: "æ–°ä¸€è½®å¼€å§‹äº†ï¼æ‰€æœ‰è¿›åº¦å·²é‡ç½®ã€‚",
    shopGuide: "ç‚¹å‡»å³ä¾§å•†åº—è´­ä¹°å¼ºåŠ›é“å…·ï¼",
    rivalryTitle: "å›½å®¶å¯¹æŠ—èµ›", gap: "å·®è·", waiting: "ç­‰å¾…ä¸­...", noRival: "æ— å¯¹æ‰‹",
    hallOfFame: "èœå•", recentPrizes: "è¿‘æœŸå¥–å“", noRecords: "æš‚æ— èŽ·èƒœè€…ã€‚æˆä¸ºç¬¬ä¸€ä¸ªèµ¢å®¶å§ï¼",
    adWatchBtn: "ðŸ“º çœ‹å¹¿å‘Š (+2000P)", shareBtn: "ðŸ’¬ åˆ†äº« (+800P)",
    adReward: "+2000 ç§¯åˆ†", shareReward: "åˆ†äº«èŽ·å¾—800P (æœ€å¤š5æ¬¡)",
    roundOverTitle: "å›žåˆç»“æŸï¼", roundOverDesc: "æ­£åœ¨ç­‰å¾…ä¸‹ä¸€è½®...",
    checkingWinnerTitle: "æ­£åœ¨åˆ¤å®šèƒœè€…...", checkingWinnerDesc: "æ­£åœ¨ç¡®è®¤è°æ˜¯ä¼ è¯´ä¸­çš„ç ´åè€…ã€‚",
    winnerTimerWarning: "è¯·åœ¨5åˆ†é’Ÿå†…è¾“å…¥ã€‚", winnerExitMsg: "å·²å‘é€ï¼å³å°†é€€å‡º (æ‰“å¼€æ–°çª—å£)", loserMsg: "å¾ˆé—æ†¾ï¼Œè¿™æ¬¡å¤±è´¥äº†ã€‚å³å°†é€€å‡º (æ‰“å¼€æ–°çª—å£)", timeLeft: "å‰©ä½™æ—¶é—´",
    retryTitle: "å‡†å¤‡å¥½å†æ¬¡å°è¯•äº†å—ï¼Ÿ", retryBtn: "ðŸ”„ é‡æ–°è¿›å…¥æ¸¸æˆ",
    tapToClose: "(ç‚¹å‡»å…³é—­)",
    maxAtkTitle: "æœ€é«˜æ”»å‡»åŠ›", maxPointTitle: "æœ€é«˜ç§¯åˆ†", maxClickTitle: "æœ€é«˜ç‚¹å‡»æ•°", serverStatusTitle: "æœåŠ¡å™¨çŠ¶æ€", participants: "å‚ä¸Žè€…", queueLabel: "æŽ’é˜Ÿä¸­", spectators: "æ—è§‚è€…", totalOnline: "Total Online"
  }
};

const getFlagEmoji = (countryCode) => {
  if (!countryCode) return 'ðŸŒ';
  const codePoints = countryCode.toUpperCase().split('').map(char => 127397 + char.charCodeAt());
  return String.fromCodePoint(...codePoints);
};

const TOOL_NAMES = {
  hammer: 'item1',
  pickaxe: 'item2',
  dynamite: 'item3',
  drill: 'item4',
  excavator: 'item5',
  laser: 'item6',
  nuke: 'item7',
  fist: 'fist'
};

function App() {
  const [route, setRoute] = useState(window.location.hash);
  
  // Custom Hook for API State
  const { serverState, API_URL, error: serverError, role, queuePos, etaSec, addClick, connected, clientId, winningToken, connect, rewardEvent } = useGameState(); 
  
  // Custom Hook for Push Notifications
  usePushNotifications(API_URL, clientId);
  
  // Local HP for Optimistic Updates
  const [hp, setHp] = useState(1000000);

  const [isShaking, setIsShaking] = useState(false);
  const [myPoints, setMyPoints] = useState(0);
  const [clickPower, setClickPower] = useState(1);
  const [isWinner, setIsWinner] = useState(false);
  const [winnerEmail, setWinnerEmail] = useState("");
  const [emailSubmitted, setEmailSubmitted] = useState(false);
  const [myCountry, setMyCountry] = useState("US");
  const [lang, setLang] = useState(TRANSLATIONS.US);
  const [currentTool, setCurrentTool] = useState("fist");
  const [showCountrySelect, setShowCountrySelect] = useState(false);
  const [adWatchCount, setAdWatchCount] = useState(0); 
  const [myTotalClicks, setMyTotalClicks] = useState(() => {
    return parseInt(localStorage.getItem('egg_breaker_clicks') || '0', 10);
  });
  
  // Track previous round to detect changes
  const prevRound = useRef(null);
  
  // Mobile Panel State: 'none', 'left', 'right'
  const [mobilePanel, setMobilePanel] = useState('none');
  const [notification, setNotification] = useState('');
  const [showGuide, setShowGuide] = useState(false);
  const [lastActivity, setLastActivity] = useState(Date.now());
  const [hideAnnouncement, setHideAnnouncement] = useState(false);

  // Timestamp for synchronization
  const lastServerTs = useRef(0);
  const buyAudioRef = useRef(null); // Singleton for buy sound

  // Timers
  const [winnerCountdown, setWinnerCountdown] = useState(300); // 5 minutes
  const [exitCountdown, setExitCountdown] = useState(null); // For winner after submit
  const [loserCountdown, setLoserCountdown] = useState(null); // For losers
  const [showLoserMessage, setShowLoserMessage] = useState(false); // Delay for "Checking..."

  // Retry & Spectator State
  const [showRetry, setShowRetry] = useState(false);
  const [isSpectating, setIsSpectating] = useState(false);
  const isFirstLoad = useRef(true); // Track first load to detect latecomers

  // Data from Server State
  const announcement = serverState.announcement || "";
  const prize = serverState.prize || "";
  const prizeUrl = serverState.prizeUrl || "";
  const adUrl = serverState.adUrl || "";

  // Helper for Game End (Open New Window + Show Retry Screen)
  const handleGameEnd = (url) => {
      try {
          // Open a new blank window/tab
          const target = url || 'about:blank';
          window.open(target, '_blank');
      } catch (e) {
          console.error("Popup blocked or failed", e);
      }
      
      // Show Retry/Spectating UI inside the game instead of a separate screen
      setShowRetry(true);
      setIsSpectating(true); 
  };

  const handleRetry = () => {
      // Complete reset by reloading the page
      window.location.reload();
  };

  // Winner Timer (5 min limit)
  useEffect(() => {
    let timer;
    if (isWinner && !emailSubmitted && winnerCountdown > 0 && !showRetry) {
      timer = setInterval(() => {
        setWinnerCountdown(prev => prev - 1);
      }, 1000);
    } else if (winnerCountdown === 0 && isWinner && !emailSubmitted && !showRetry) {
       // Time expired for winner
       alert("Time expired! You failed to enter your email in time.");
       handleGameEnd(adUrl);
    }
    return () => clearInterval(timer);
  }, [isWinner, emailSubmitted, winnerCountdown, adUrl, showRetry]);

  // Winner Exit Timer (after submission)
  useEffect(() => {
    let timer;
    if (exitCountdown !== null && exitCountdown > 0 && !showRetry) {
        timer = setInterval(() => setExitCountdown(prev => prev - 1), 1000);
    } else if (exitCountdown === 0 && !showRetry) {
        handleGameEnd(adUrl);
    }
    return () => clearInterval(timer);
  }, [exitCountdown, adUrl, showRetry]);

  // Loser Logic & Timer
  useEffect(() => {
      let checkTimer;
      let countdownTimer;

      if (hp <= 0 && !isWinner && !showRetry && !isSpectating) {
          // 1. Wait 4 seconds before showing "Failed" (to allow server sync)
          if (!showLoserMessage) {
              checkTimer = setTimeout(() => {
                  setShowLoserMessage(true);
                  setLoserCountdown(10); // 10 seconds to exit
              }, 4000);
          }

          // 2. Start Countdown if message is shown
          if (showLoserMessage && loserCountdown !== null && loserCountdown > 0) {
              countdownTimer = setInterval(() => {
                  setLoserCountdown(prev => prev - 1);
              }, 1000);
          } else if (showLoserMessage && loserCountdown === 0) {
              handleGameEnd(adUrl);
          }
      } else {
          // Reset if HP restored (new round) or became winner
          if (hp > 0) {
            setShowLoserMessage(false);
            setLoserCountdown(null);
            setIsSpectating(false);
          }
      }

      return () => {
          clearTimeout(checkTimer);
          clearInterval(countdownTimer);
      };
  }, [hp, isWinner, showLoserMessage, loserCountdown, adUrl, showRetry, isSpectating]);

  // 1. Definition FIRST
  const changeCountry = (code) => {
    const targetLang = ["KR", "JP", "CN"].includes(code) ? code : "US";
    setMyCountry(code);
    setLang(TRANSLATIONS[targetLang]);
    setShowCountrySelect(false);
  };

  // 2. useEffects using functions
  useEffect(() => {
    const detectCountry = async () => {
        try {
            const res1 = await fetch('https://ipwho.is/');
            const data1 = await res1.json();
            if (data1.success && data1.country_code) {
                changeCountry(data1.country_code);
                return;
            }
            throw new Error("ipwho.is failed");
        } catch (e) {
            changeCountry("US");
        }
    };
    detectCountry();
  }, []);

  // Handle Invite Link Check
  useEffect(() => {
      const checkInvite = async (url) => {
          console.log(`[App] URL: ${url}`);
          if (!url) return;
          const params = new URLSearchParams(new URL(url).search);
          const referrer = params.get('referrer');
          console.log(`[App] Ref: ${referrer}, Me: ${clientId}`);
          
          // Remove client-side check to allow round resets to work
          if (referrer && referrer !== clientId) {
              try {
                  console.log("[App] Sending invite req...");
                  const res = await fetch(`${API_URL}/api/invite-reward`, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ from: referrer, to: clientId })
                  });
                  const json = await res.json();
                  console.log(`[App] Resp: ${res.status} ${JSON.stringify(json)}`);
                  
                  if (res.ok) {
                      console.log("Invite verified by server!");
                      // Optional: mark locally if needed for UI, but rely on server for logic
                  }
              } catch (e) {
                  console.error("Invite check failed", e);
                  console.log(`[App] Err: ${e.message}`);
              }
          } else {
              console.log("[App] No valid referrer");
          }
      };
      
      checkInvite(window.location.href);
      
      // For Capacitor (Deep Links)
      if (window.Capacitor) {
          import('@capacitor/app').then(({ App: CapApp }) => {
              CapApp.addListener('appUrlOpen', data => {
                  checkInvite(data.url);
              });
          });
      }
  }, [clientId, API_URL]);

  // Handle Reward Events (Invites)
  useEffect(() => {
    if (rewardEvent) {
        setMyPoints(prev => prev + rewardEvent.amount);
        // Persist earned points locally as well
        const currentStored = parseInt(localStorage.getItem('saved_points') || '0', 10);
        localStorage.setItem('saved_points', (currentStored + rewardEvent.amount).toString());

        const msg = rewardEvent.msg === "inviteSuccess" 
            ? (lang.inviteSuccess || "Friend joined! +800P") 
            : rewardEvent.msg;
        alert(msg);
        console.log(`[App] Reward: ${msg}`);
    }
  }, [rewardEvent, lang]);

  // ... (Sync Local HP Logic) ... 
  // (We need to insert the render part before the closing brace of the component)


  // Sync Local HP with Server HP (Correction with Pending Damage)
  useEffect(() => {
      if (serverState.hp !== undefined) {
          // [DEBUG] ì¦ê±° í™•ë³´ìš© ë¡œê·¸
          if (serverState.rev) {
             console.log(`[SYNC] Rev:${serverState.rev} TS:${serverState.lastUpdatedAt} ServerHP:${serverState.hp}`);
          }

          // íƒ€ìž„ìŠ¤íƒ¬í”„ ì²´í¬: ë” ì˜¤ëž˜ëœ ë°ì´í„°ê°€ ìµœì‹  ë°ì´í„°ë¥¼ ë®ì–´ì“°ëŠ” ê²ƒ ë°©ì§€ (Race Condition í•´ê²°)
          const ts = serverState.lastUpdatedAt || 0;
          
          if (ts >= lastServerTs.current) {
              lastServerTs.current = ts;
              
              setHp(serverState.hp);

              // Latecomer Detection
              if (isFirstLoad.current) {
                  if (serverState.hp <= 0) {
                      setIsSpectating(true);
                  }
                  
                  // [Opt] Restore saved points on first load (from ads/invites)
                  const savedPoints = parseInt(localStorage.getItem('saved_points') || '0', 10);
                  if (savedPoints > 0) {
                      setMyPoints(prev => prev + savedPoints);
                  }

                  isFirstLoad.current = false;
              }
              
              if (serverState.winnerInfo && serverState.winnerInfo.country === myCountry && !isWinner) {
                  // Check if it matches me? We don't have ID check here easily yet without more logic.
                  // Assume if "I" triggered the win, isWinner is set locally.
                  // If someone else won, we see status FINISHED.
              }
          } 
      }
  }, [serverState.hp, serverState.lastUpdatedAt, myCountry, isWinner]);
  
  // Removed manual flushPendingDamage logic (handled in hook)

  useEffect(() => {
    // Round change handling
    if (prevRound.current && serverState.round && serverState.round !== prevRound.current) {
        setMyPoints(0);
        setClickPower(1);
        setCurrentTool('fist');
        setAdWatchCount(0);
        setMyTotalClicks(0);
        localStorage.setItem('egg_breaker_clicks', '0');
        localStorage.setItem('saved_points', '0'); // Reset saved points too
    }
    if (serverState.round) {
        prevRound.current = serverState.round;
    }
  }, [serverState.round, serverState.status, lang]);

  useEffect(() => {
    const handleHashChange = () => {
      setRoute(window.location.hash);
    };

    window.addEventListener('hashchange', handleHashChange);
    return () => window.removeEventListener('hashchange', handleHashChange);
  }, []);

  useEffect(() => {
    if (window.Kakao && !window.Kakao.isInitialized()) {
        const kakaoKey = import.meta.env.VITE_KAKAO_JAVASCRIPT_KEY;
        if(kakaoKey && kakaoKey !== 'YOUR_KAKAO_JAVASCRIPT_KEY') {
             try { window.Kakao.init(kakaoKey); } catch(e) { console.error("Kakao Init Failed:", e); }
        }
    }
  }, []);

  // Inactivity Timer for Guide
  useEffect(() => {
    const timer = setInterval(() => {
      if (Date.now() - lastActivity > 10000 && !showGuide) {
        setShowGuide(true);
      }
    }, 1000);
    return () => clearInterval(timer);
  }, [lastActivity, showGuide]);

  const handleClick = async () => {
    if (hp <= 0 || serverState.status === 'FINISHED' || role === 'spectator') return;
    
    // Reset activity timer
    setLastActivity(Date.now());
    setShowGuide(false);
    
    // 1. [Optimistic Update] UI ì¦‰ì‹œ ë°˜ì˜
    setIsShaking(true);
    setTimeout(() => setIsShaking(false), 100);
    
    const newHp = Math.max(0, hp - clickPower);
    
    // ë¡œì»¬ ìƒíƒœ ì¦‰ì‹œ ë³€ê²½
    setMyPoints(prev => prev + clickPower);
    setHp(newHp);
    
    // ë¡œì»¬ í†µê³„ ê°±ì‹ 
    const newTotalClicks = myTotalClicks + 1;
    setMyTotalClicks(newTotalClicks);
    localStorage.setItem('egg_breaker_clicks', newTotalClicks.toString());

    // Use Hook to Add Click
    addClick(clickPower, myCountry, myPoints + clickPower, newTotalClicks);
    
    // If HP hits 0 locally, we rely on server to confirm.
    if (newHp === 0) {
       setIsWinner(true); // Tentative
    }
  };

  const buyItem = async (cost, powerAdd, toolName) => {
    if (myPoints >= cost) {
      setMyPoints(prev => prev - cost);
      setClickPower(prev => prev + powerAdd);
      setCurrentTool(toolName);
      
      // Play Buy Sound (Hybrid)
      try {
          if (Capacitor.isNativePlatform()) {
              // Assuming 'buy' is preloaded in GameArea, but App might be separate.
              // Safer to load-and-play or assume GameArea loaded it. 
              // NativeAudio shares state globally per app.
              await NativeAudio.play({ assetId: 'buy' });
          } else {
              if (!buyAudioRef.current) {
                  buyAudioRef.current = new Audio('/sounds/buy.mp3');
                  buyAudioRef.current.volume = 0.5;
              }
              buyAudioRef.current.currentTime = 0;
              buyAudioRef.current.play().catch(e => console.log("Buy sound fail", e));
          }
      } catch(e) { console.log('Buy sound error', e); }

      const localizedToolName = lang[TOOL_NAMES[toolName]] || toolName;
      alert(`${lang.bought} ${localizedToolName}!`);
      showNotification(`${lang.bought} ${localizedToolName}!`);
    } else {
      alert(lang.notEnoughPoints);
    }
  };

  const submitWinnerEmail = async () => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(winnerEmail)) {
        alert("ì´ë©”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
        return;
    }
    
    try {
        await fetch(`${API_URL}/api/winner`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: winnerEmail, country: myCountry, token: winningToken })
        });
        setEmailSubmitted(true);
        // Start exit timer
        setExitCountdown(5); 
    } catch(e) {
        console.error("Winner submit failed", e);
        alert("Failed to send. Please try again.");
    }
  };

  const showNotification = (msg) => {
      setNotification(msg);
      setTimeout(() => setNotification(''), 2000);
  };

  const toggleMobilePanel = (panel) => {
    if (mobilePanel === panel) {
        setMobilePanel('none');
    } else {
        setMobilePanel(panel);
        setShowCountrySelect(false); // Close language dropdown if panel opens
    }
  };

  const handleLangToggle = () => {
      if (!showCountrySelect) {
          setMobilePanel('none'); // Close any open panel
          setShowCountrySelect(true);
      } else {
          setShowCountrySelect(false);
      }
  };

  const handleKakaoShare = () => {
    if (!window.Kakao || !window.Kakao.isInitialized()) {
        alert("Kakao SDK not initialized.");
        return;
    }
    
    // Construct Share URL with Referrer
    const currentUrl = new URL(window.location.href);
    currentUrl.searchParams.set('referrer', clientId);
    const shareUrl = currentUrl.toString();

    // 1. Launch Share
    // NOTE: Error 4019 means domain mismatch. Register domain in Kakao Developers.
    window.Kakao.Share.sendDefault({
      objectType: 'feed',
      content: {
        title: lang.title,
        description: lang.subtitle,
        imageUrl: 'https://egg-break-412ae.web.app/vite.svg', // TODO: Replace with actual game image URL
        link: { mobileWebUrl: shareUrl, webUrl: shareUrl },
      },
      buttons: [{ title: 'Play Now', link: { mobileWebUrl: shareUrl, webUrl: shareUrl } }],
    });

    // 2. Inform user
    alert(lang.shareSuccess);
  };

  const handleAdWatch = () => {
    if (adWatchCount >= 1) {
        alert("ì´ë²ˆ ë¼ìš´ë“œ ê´‘ê³  ì‹œì²­(1íšŒ)ì„ ì´ë¯¸ ì™„ë£Œí•˜ì…¨ìŠµë‹ˆë‹¤!");
        return;
    }
    if (adUrl) {
        window.open(adUrl, '_blank');
    } else {
        alert("í˜„ìž¬ ì—°ê²°ëœ ê´‘ê³ ê°€ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }
    const reward = 2000;
    setMyPoints(prev => prev + reward);
    setAdWatchCount(prev => prev + 1);
    
    // [Opt] Persist ad reward locally
    const currentStored = parseInt(localStorage.getItem('saved_points') || '0', 10);
    localStorage.setItem('saved_points', (currentStored + reward).toString());
    
    alert(`ê´‘ê³  ì‹œì²­ ì™„ë£Œ! ${reward} í¬ì¸íŠ¸ê°€ ì§€ê¸‰ë˜ì—ˆìŠµë‹ˆë‹¤.`);
  };

  if (route === '#admin') return <Admin />;

  // 1. Server Full / Queue Full Error
  if (serverError === 'FULL') {
      return (
          <div style={{
              display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
              height: '100vh', background: '#fff0f5', color: '#5d4037', textAlign: 'center', padding: '20px'
          }}>
              <div style={{ fontSize: '4rem', marginBottom: '20px' }}>ðŸš«</div>
              <h1 style={{ color: '#ff6f61', marginBottom: '10px' }}>ëŒ€ê¸°ì—´ ë§Œì›</h1>
              <p style={{ fontSize: '1.1rem', lineHeight: '1.6' }}>
                  í˜„ìž¬ ì°¸ì—¬ ê°€ëŠ¥í•œ ì¸ì›ì´ ëª¨ë‘ ì°¼ìŠµë‹ˆë‹¤.<br/>
                  ìž ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.
              </p>
              <button onClick={() => window.location.reload()} style={{
                  marginTop: '20px', padding: '10px 20px', background: '#ff6f61', color: 'white', border: 'none', borderRadius: '20px', cursor: 'pointer'
              }}>ìƒˆë¡œê³ ì¹¨</button>
          </div>
      );
  }

  // Debug: Loading State
  if (serverState.status === 'LOADING') {
      return (
          <div style={{
              display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
              height: '100vh', background: '#fff'
          }}>
              <h2>ðŸ”„ Connecting...</h2>
              <p>ì„œë²„ì™€ ì—°ê²° ì¤‘ìž…ë‹ˆë‹¤.</p>
          </div>
      );
  }

  // Debug: Error State
  if (serverState.status === 'ERROR') {
      return (
          <div style={{
              display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
              height: '100vh', background: '#fff', padding: '20px', textAlign: 'center'
          }}>
              <h2 style={{color: 'red'}}>âš ï¸ Connection Error</h2>
              <p>{serverState.announcement}</p>
              <p style={{fontSize: '0.8rem', color: '#666', marginTop: '10px'}}>
                  Check your internet connection or server URL.
              </p>
              <p style={{fontSize: '0.7rem', color: '#aaa'}}>API: {API_URL}</p>
              <button onClick={() => window.location.reload()} style={{marginTop: '20px'}}>Retry</button>
          </div>
      );
  }

  // 2. Spectator Mode (Not Connected)
  if (!connected) {
      // Polling Mode View
      // Show Game Area but with overlay if PLAYING
      // If FINISHED or WINNER_CHECK, just show the state (GameArea handles it)
  }

  // Transform server stats for UI
  const countryStats = Object.entries(serverState.clicksByCountry || {})
    .sort((a, b) => b[1] - a[1]);

  const onlineUsersCount = (serverState.onlinePlayers || 0) + (serverState.onlineSpectatorsApprox || 0);

  return (
    <div className="app-container">
      <Header 
        lang={lang} 
        myCountry={myCountry} 
        getFlagEmoji={getFlagEmoji} 
        onToggleLanguage={handleLangToggle} 
        showCountrySelect={showCountrySelect} 
        changeCountry={changeCountry}
        toggleMobilePanel={toggleMobilePanel} 
      />
      
      {announcement && !hideAnnouncement && (
        <div 
          onClick={() => setHideAnnouncement(true)}
          style={{
            background: '#ffefd5', color: '#ff6f61', padding: '12px', textAlign: 'center', fontWeight: 'bold',
            animation: 'fadeIn 0.5s', borderRadius: '0 0 20px 20px', boxShadow: '0 4px 10px rgba(0,0,0,0.05)',
            border: '1px solid #ffe4e1', marginBottom: '10px', cursor: 'pointer'
          }}
        >
          ðŸ“¢ {announcement} <span style={{ fontSize: '0.8rem', opacity: 0.7, fontWeight: 'normal', marginLeft: '5px' }}>{lang.tapToClose}</span>
        </div>
      )}

      {/* Backdrop for closing menus on click outside */}
      {(mobilePanel !== 'none' || showCountrySelect) && (
        <div 
            onClick={() => { setMobilePanel('none'); setShowCountrySelect(false); }}
            style={{
                position: 'fixed',
                top: 0, left: 0, width: '100%', height: '100%',
                background: 'rgba(0,0,0,0.3)', // Semi-transparent dimming
                zIndex: 1500, // Below panels (2000) but above everything else
                cursor: 'pointer'
            }}
        />
      )}

      <div className="main-layout">
        <LeftPanel 
          lang={lang} 
          serverState={serverState}
          countryStats={countryStats} 
          onlineUsersCount={onlineUsersCount} 
          prize={prize}
          prizeUrl={prizeUrl}
          getFlagEmoji={getFlagEmoji}
          isOpen={mobilePanel === 'left'}
          toggleMobilePanel={toggleMobilePanel}
        />

        <InfoPanel
          lang={lang}
          recentWinners={serverState.recentWinners || []}
          prize={prize}
          prizeUrl={prizeUrl}
          isOpen={mobilePanel === 'info'}
          toggleMobilePanel={toggleMobilePanel}
        />

        {/* Game Area Wrapper for Overlays */}
        <div style={{ position: 'relative', flex: 1, display: 'flex', justifyContent: 'center' }}>
            <GameArea 
              lang={lang}
              hp={hp}
              isShaking={isShaking}
              clickPower={clickPower}
              myPoints={myPoints}
              isWinner={isWinner}
              emailSubmitted={emailSubmitted}
              winnerEmail={winnerEmail}
              setWinnerEmail={setWinnerEmail}
              submitWinnerEmail={submitWinnerEmail}
              handleClick={handleClick}
              currentTool={currentTool}
              buyItem={buyItem}
              notification={notification}
              handleAdWatch={handleAdWatch}
              showGuide={showGuide}
              winnerCountdown={winnerCountdown}
              exitCountdown={exitCountdown}
              loserCountdown={loserCountdown}
              showLoserMessage={showLoserMessage}
              isSpectating={isSpectating} // This logic needs update in GameArea
              showRetry={showRetry}
              handleRetry={handleRetry}
              clientId={clientId}
              serverState={serverState}
              API_URL={API_URL}
              myCountry={myCountry}
              winningToken={winningToken}
              connected={connected}
            />

            {/* JOIN BUTTON OVERLAY (When NOT connected and PLAYING) */}
            {!connected && serverState.status === 'PLAYING' && (
                <div style={{
                    position: 'absolute', top: 0, left: 0, width: '100%', height: '100%',
                    background: 'rgba(255, 255, 255, 0.4)', // Slightly dim
                    display: 'flex', alignItems: 'center', justifyContent: 'center',
                    zIndex: 1000, backdropFilter: 'blur(2px)'
                }}>
                    <button 
                        onClick={connect}
                        className="pulse-btn"
                        style={{
                            padding: '20px 50px', fontSize: '2rem', fontWeight: '900',
                            background: 'linear-gradient(45deg, #ff6f61, #ff9a9e)',
                            color: 'white', border: 'none', borderRadius: '50px',
                            cursor: 'pointer', boxShadow: '0 10px 30px rgba(255, 111, 97, 0.5)',
                            transform: 'scale(1)', transition: 'transform 0.2s',
                            textShadow: '0 2px 4px rgba(0,0,0,0.2)'
                        }}
                    >
                        âš”ï¸ {lang.joinGame || "JOIN GAME"}
                    </button>
                </div>
            )}
        </div>

        <RightPanel 
          lang={lang}
          buyItem={buyItem}
          myPoints={myPoints}
          clickPower={clickPower}
          myTotalClicks={myTotalClicks}
          handleKakaoShare={handleKakaoShare}
          isOpen={mobilePanel === 'right'}
          toggleMobilePanel={toggleMobilePanel}
        />
      </div>
    </div>
  );
}

export default App;
[FILE_CONTENT_END:egg-breaker/src/App.jsx]

// --- FILE: egg-breaker/src/hooks/useGameState.js (Communication Hook) ---
/*
  A custom hook that handles WebSocket connection and API polling.
  It encapsulates the logic for joining the game, receiving state updates,
  and sending click data to the server in batches.
*/
[FILE_CONTENT_START:egg-breaker/src/hooks/useGameState.js]
import { useState, useEffect, useRef, useCallback } from 'react';

// VITE_API_URL should be set
let rawApiUrl = import.meta.env.VITE_API_URL || "http://localhost:8787";
// Normalize URL: remove trailing /api or /
if (rawApiUrl.endsWith('/api')) {
    rawApiUrl = rawApiUrl.substring(0, rawApiUrl.length - 4);
}
if (rawApiUrl.endsWith('/')) {
    rawApiUrl = rawApiUrl.substring(0, rawApiUrl.length - 1);
}
const API_URL = rawApiUrl;

const getWsUrl = (apiUrl) => {
    return apiUrl.replace(/^http/, 'ws') + "/ws";
};

const WS_URL = getWsUrl(API_URL);

export function useGameState() {
  const [serverState, setServerState] = useState({
    hp: 1000000,
    maxHp: 1000000,
    round: 1,
    status: 'LOADING', // Changed from FINISHED to debug
    clicksByCountry: {},
    onlinePlayers: 0,
    onlineSpectatorsApprox: 0,
    maxAtk: 0,
    maxAtkCountry: "UN",
    maxPoints: 0,
    maxClicks: 0,
    announcement: "",
    prize: "",
    prizeUrl: "",
    adUrl: "",
    rev: 0,
    lastUpdatedAt: 0,
    recentWinners: []
  });
  
  const [role, setRole] = useState(null); // 'player' | 'spectator' | null (polling)
  const [queuePos, setQueuePos] = useState(null);
  const [etaSec, setEtaSec] = useState(null);
  const [error, setError] = useState(null);
  const [connected, setConnected] = useState(false);
  const [winningToken, setWinningToken] = useState(null);
  const [rewardEvent, setRewardEvent] = useState(null);

  const wsRef = useRef(null);
  const clickAccumulator = useRef(0);
  const maxPowerInBatch = useRef(0);
  const latestPoints = useRef(0);
  const latestTotalClicks = useRef(0);
  const lastDeltaSentTime = useRef(0);
  
  // Persist Client ID across reloads/tabs
  const clientIdRef = useRef(() => {
      let stored = localStorage.getItem('egg_game_client_id');
      if (!stored) {
          stored = crypto.randomUUID();
          localStorage.setItem('egg_game_client_id', stored);
      }
      return stored;
  });
  
  // Fix: useRef value initialization needs to be called if function
  const clientId = typeof clientIdRef.current === 'function' ? clientIdRef.current() : clientIdRef.current;
  clientIdRef.current = clientId; // Ensure ref holds the string value

  const countryRef = useRef("UN");
  const pollingIntervalRef = useRef(null);

  // --- 1. Polling Logic (Default) ---
  const fetchState = async () => {
      try {
          // console.log(`[Polling] Fetching ${API_URL}/api/state`); // Log attempt
          const res = await fetch(`${API_URL}/api/state`);
          if (res.ok) {
              const data = await res.json();
              // console.log("[Polling] Success:", data); // Log success
              setServerState(prev => {
                  if (data.lastUpdatedAt < prev.lastUpdatedAt && data.round === prev.round) return prev;
                  return data;
              });
          } else {
             console.error(`[Polling] Failed: ${res.status}`);
          }
      } catch (e) {
          console.error("[Polling] Error:", e); // Log specific error
          setServerState(prev => ({ ...prev, status: 'ERROR', announcement: e.message }));
      }
  };

  useEffect(() => {
      // Start polling if NOT connected
      if (!connected) {
          fetchState(); // Initial fetch
          pollingIntervalRef.current = setInterval(fetchState, 10000);
      } else {
          if (pollingIntervalRef.current) clearInterval(pollingIntervalRef.current);
      }

      return () => {
          if (pollingIntervalRef.current) clearInterval(pollingIntervalRef.current);
      };
  }, [connected]);


  // --- 2. WebSocket Logic (On-Demand) ---
  const connect = useCallback(() => {
    // Prevent duplicate connection if already connected or connecting
    if (wsRef.current && (wsRef.current.readyState === WebSocket.OPEN || wsRef.current.readyState === WebSocket.CONNECTING)) {
        return;
    }

    const url = `${WS_URL}?mode=player`; // Always try to be player/queue
    const ws = new WebSocket(url);
    wsRef.current = ws;

    ws.onopen = () => {
      console.log("[WS] Connected");
      setConnected(true);
      setError(null);
      
      ws.send(JSON.stringify({
          type: "join",
          mode: "player",
          clientId: clientIdRef.current,
          country: countryRef.current
      }));
    };

    ws.onmessage = (event) => {
      try {
        const msg = JSON.parse(event.data);
        switch (msg.type) {
            case 'join_ok':
                setRole(msg.role);
                setQueuePos(msg.queuePos);
                console.log(`[WS] Joined as ${msg.role}`);
                break;
            case 'state':
                setServerState(prev => {
                   if (msg.lastUpdatedAt < prev.lastUpdatedAt && msg.round === prev.round) return prev;
                   return msg;
                });
                break;
            case 'queue_update':
                setQueuePos(msg.queuePos);
                setEtaSec(msg.etaSec);
                break;
            case 'you_won':
                console.log("ðŸŽ‰ I WON!", msg.token);
                setWinningToken(msg.token);
                break;
            case 'invite_reward':
                console.log("ðŸŽ Invite Reward!", msg.amount);
                setRewardEvent({ amount: msg.amount, msg: msg.msg, id: Date.now() });
                break;
            case 'error':
                console.error("[WS] Error:", msg.message);
                if (msg.code === 'FULL' || msg.code === 'ROUND_NOT_STARTED') {
                    setError(msg.code);
                    ws.close(); // Close immediately if rejected
                }
                break;
            default: break;
        }
      } catch (e) { console.error(e); }
    };

    ws.onclose = () => {
        console.log("[WS] Closed");
        setConnected(false);
        setRole(null);
        setQueuePos(null);
        // Do NOT auto-reconnect. Fallback to polling.
    };

    ws.onerror = (err) => {
        console.error("[WS] Error", err);
        ws.close();
    };
  }, []);

  const disconnect = useCallback(() => {
      if (wsRef.current) {
          wsRef.current.close();
      }
  }, []);

  // --- 3. Click Sender ---
  useEffect(() => {
    const interval = setInterval(() => {
        if (wsRef.current?.readyState === WebSocket.OPEN && clickAccumulator.current > 0) {
            const now = Date.now();
            wsRef.current.send(JSON.stringify({
                type: 'click_delta',
                clientId: clientIdRef.current,
                delta: clickAccumulator.current,
                atk: maxPowerInBatch.current,
                points: latestPoints.current,
                totalClicks: latestTotalClicks.current,
                country: countryRef.current,
                ts: now
            }));
            clickAccumulator.current = 0;
            maxPowerInBatch.current = 0;
            lastDeltaSentTime.current = now;
        }
    }, 5000); // 5s Buffer

    return () => clearInterval(interval);
  }, []);

  const addClick = (power, country, currentPoints, totalClicks) => {
      clickAccumulator.current += power;
      if (power > maxPowerInBatch.current) {
          maxPowerInBatch.current = power;
      }
      latestPoints.current = currentPoints;
      latestTotalClicks.current = totalClicks;
      if (country) countryRef.current = country;
  };

  return { 
      serverState, 
      API_URL, 
      error, 
      connected, 
      role, 
      queuePos, 
      etaSec,
      addClick, 
      connect, // Expose connect function
      disconnect,
      clientId: clientIdRef.current,
      winningToken,
      rewardEvent
  };
}
[FILE_CONTENT_END:egg-breaker/src/hooks/useGameState.js]

// --- FILE: egg-breaker/src/components/GameArea.jsx (Visuals & Interaction) ---
/*
  The visual core of the game. It renders:
  - The SVG Egg with dynamic cracks and expressions based on HP.
  - Floating damage numbers, tool icons, and particles on click.
  - Haptic feedback and sound effects (Native and Web).
  - Modals for winner claiming and round end.
*/
[FILE_CONTENT_START:egg-breaker/src/components/GameArea.jsx]
import React, { useState, useRef, useEffect } from 'react';
import { Haptics, ImpactStyle } from '@capacitor/haptics';
import { NativeAudio } from '@capacitor-community/native-audio';
import { Capacitor } from '@capacitor/core';

// (CrackedEgg SVG component logic and particle effects)
// ... [Full Code follows below]
[FILE_CONTENT_START:egg-breaker/src/components/GameArea.jsx]
import React, { useState, useRef, useEffect } from 'react';
import { Haptics, ImpactStyle } from '@capacitor/haptics';
import { NativeAudio } from '@capacitor-community/native-audio';
import { Capacitor } from '@capacitor/core';

// --- ê¹¨ì§€ëŠ” ì•Œ SVG ì»´í¬ë„ŒíŠ¸ ---
const CrackedEgg = ({ hp, maxHp, isShaking, tool, onEggClick }) => {
    const percentage = (hp / maxHp) * 100;

    // ì²´ë ¥ì— ë”°ë¥¸ ê¸ˆ(Crack) ë‹¨ê³„ ê²°ì •
    const showCrack1 = percentage < 80;
    const showCrack2 = percentage < 70;
    const showCrack3 = percentage < 20;
    const isCritical = percentage < 20 && hp > 0; // Critical Phase (Dark Mode)

    // í‘œì • ê²°ì • ë¡œì§
    let eyeLeft = <circle cx="75" cy="110" r="8" fill="#5d4037" />;
    let eyeRight = <circle cx="125" cy="110" r="8" fill="#5d4037" />;
    let mouth = <path d="M90 135 Q100 145 110 135" fill="none" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />; // Smile
    let blush = (
        <>
            <ellipse cx="65" cy="125" rx="8" ry="4" fill="#ffb6c1" opacity="0.6" />
            <ellipse cx="135" cy="125" rx="8" ry="4" fill="#ffb6c1" opacity="0.6" />
        </>
    );

    if (hp <= 0) {
        // ê¹¨ì§ (X X ëˆˆ)
        eyeLeft = <path d="M68 103 L82 117 M82 103 L68 117" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />;
        eyeRight = <path d="M118 103 L132 117 M132 103 L118 117" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />;
        mouth = <circle cx="100" cy="140" r="10" fill="none" stroke="#5d4037" strokeWidth="3" />; // O ìž…
    } else if (isCritical) {
        // í­ì£¼/ìœ„ê¸° ìƒíƒœ (ë¶‰ì€ ëˆˆ, ë¾°ì¡±í•œ ì´ë¹¨)
        eyeLeft = (
            <g>
                 <path d="M65 105 L85 115 L65 120" fill="red" /> {/* Sharp Red Eye */}
                 <circle cx="72" cy="112" r="2" fill="#fff" />
            </g>
        );
        eyeRight = (
            <g>
                 <path d="M135 105 L115 115 L135 120" fill="red" /> {/* Sharp Red Eye */}
                 <circle cx="128" cy="112" r="2" fill="#fff" />
            </g>
        );
        mouth = (
             <path d="M85 140 L90 130 L95 140 L100 130 L105 140 L110 130 L115 140" fill="none" stroke="#5d4037" strokeWidth="2" /> // Jagged teeth
        );
        blush = null; // No blush when angry
    } else if (isShaking) {
        // ì•„í”” (> < ëˆˆ)
        eyeLeft = <path d="M68 110 L75 117 L82 110" fill="none" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />;
        eyeRight = <path d="M118 110 L125 117 L132 110" fill="none" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />;
        mouth = <circle cx="100" cy="140" r="6" fill="#5d4037" />; // 'o' ìž…
    } else if (percentage < 70) { // Changed threshold for Sad face
        // íž˜ë“¦ (ìš¸ìƒ)
        eyeLeft = <path d="M68 115 Q75 105 82 115" fill="none" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />;
        eyeRight = <path d="M118 115 Q125 105 132 115" fill="none" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />;
        mouth = <path d="M90 145 Q100 135 110 145" fill="none" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />; // Frown
        // ëˆˆë¬¼
        blush = (
             <>
                <path d="M65 125 Q60 135 65 145" fill="#a1c4fd" />
                <path d="M135 125 Q140 135 135 145" fill="#a1c4fd" />
             </>
        );
    }

    return (
        <div className={`egg-svg-container ${isShaking ? 'shake' : ''} cursor-${tool}`}>
            <svg viewBox="0 0 200 250" className="egg-svg" style={{ overflow: 'visible' }}>
                <defs>
                    <radialGradient id="eggGradient" cx="40%" cy="30%" r="80%">
                        <stop offset="0%" stopColor={isCritical ? "#800000" : "#ffdde1"} /> {/* Dark Red when critical */}
                        <stop offset="100%" stopColor={isCritical ? "#200000" : "#ff9a9e"} />
                    </radialGradient>
                    <filter id="glow">
                        <feGaussianBlur stdDeviation="4" result="coloredBlur" />
                        <feMerge><feMergeNode in="coloredBlur" /><feMergeNode in="SourceGraphic" /></feMerge>
                    </filter>
                    {isCritical && (
                         <filter id="redGlow">
                            <feDropShadow dx="0" dy="0" stdDeviation="10" floodColor="red" />
                         </filter>
                    )}
                </defs>

                {/* 1. ì•Œ ë³¸ì²´ - ì—¬ê¸°ì—ë§Œ í´ë¦­ ì´ë²¤íŠ¸ë¥¼ ì¤ë‹ˆë‹¤ (ì •ë°€ íƒ€ê²©) */}
                <ellipse 
                    cx="100" cy="125" rx="80" ry="110" 
                    fill="url(#eggGradient)" 
                    filter={isCritical ? "url(#redGlow)" : "url(#glow)"} 
                    onPointerDown={onEggClick}
                    style={{ cursor: 'pointer', touchAction: 'none' }} 
                />
                
                {/* 2. ì–¼êµ´ (Face) - ì–¼êµ´ì„ ëˆŒëŸ¬ë„ í´ë¦­ë˜ë„ë¡ */}
                <g className="egg-face" style={{ transition: 'all 0.2s', pointerEvents: 'none' }}>
                    {blush}
                    {eyeLeft}
                    {eyeRight}
                    {mouth}
                </g>

                {/* 3. ê¸ˆ(Cracks) - í´ë¦­ í†µê³¼ (pointerEvents: none ê¸°ë³¸ê°’) */}
                {showCrack1 && (
                    <path d="M100 30 L110 50 L90 60 L105 80" fill="none" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" opacity="0.6" style={{ pointerEvents: 'none' }} />
                )}
                {showCrack2 && (
                    <path d="M50 100 L80 110 L60 130 L90 140 L70 160" fill="none" stroke="#5d4037" strokeWidth="4" strokeLinecap="round" opacity="0.7" style={{ pointerEvents: 'none' }} />
                )}
                {showCrack3 && (
                    <path d="M130 90 L110 110 L140 130 L120 160 L150 180" fill="none" stroke="#5d4037" strokeWidth="4" strokeLinecap="round" opacity="0.8" style={{ pointerEvents: 'none' }} />
                )}
                {/* HP 0ì¼ ë•Œ (ì™„ì „ ê¹¨ì§) */}
                {hp <= 0 && (
                    <path d="M20 125 L180 125" fill="none" stroke="#5d4037" strokeWidth="10" style={{ pointerEvents: 'none' }} />
                )}
            </svg>
        </div>
    );
};

const TOOL_EMOJIS = {
    hammer: 'ðŸ”¨',
    pickaxe: 'â›ï¸',
    dynamite: 'ðŸ§¨',
    drill: 'ðŸ”©',
    excavator: 'ðŸšœ',
    laser: 'ðŸ”«',
    nuke: 'â˜¢ï¸',
    fist: 'ðŸ‘Š'
};

const CUTE_PARTICLES = ['âœ¨', 'ðŸ’–', 'ðŸŒ¸', 'ðŸ­', 'â­', 'ðŸŒˆ', 'ðŸ¦', 'ðŸŽ€', 'ðŸŽµ', 'ðŸ‡'];

const GameArea = ({
    lang, hp, isShaking, clickPower, myPoints, isWinner, emailSubmitted, winnerEmail,
    setWinnerEmail, submitWinnerEmail, handleClick, currentTool, buyItem, notification, handleAdWatch, showGuide,
    winnerCountdown, exitCountdown, loserCountdown, showLoserMessage, isSpectating, showRetry, handleRetry,
    clientId, serverState, API_URL, myCountry, winningToken, connected
}) => {
    const [clickEffects, setClickEffects] = useState([]);
    const stageRef = useRef(null); // ìŠ¤í…Œì´ì§€ ì¢Œí‘œ ê¸°ì¤€ì 
    const wasActivePlayer = useRef(false);
    const [localLoserTimer, setLocalLoserTimer] = useState(null);
    const [showWinnerClaiming, setShowWinnerClaiming] = useState(false);
    
    // Settings Toggle State
    const [isSettingsOpen, setIsSettingsOpen] = useState(false);
    
    // --- Sound State (Persisted in localStorage) ---
    const [audioLoaded, setAudioLoaded] = useState(false); 

    const [isSoundOn, setIsSoundOn] = useState(() => {
        const saved = localStorage.getItem('soundOn');
        return saved !== null ? JSON.parse(saved) : true;
    });

    const [isBgmOn, setIsBgmOn] = useState(() => {
        const saved = localStorage.getItem('bgmOn');
        return saved !== null ? JSON.parse(saved) : true;
    });

    // BGM & SFX Refs
    const webAudioRefs = useRef({});
    const bgmRef = useRef(null); // For Web Audio BGM
    const currentPhaseRef = useRef('none');

    useEffect(() => {
        const sounds = [
            'fist', 'hammer', 'pickaxe', 'dynamite', 'drill', 'excavator', 'laser', 'nuke', 
            'buy', 'win'
        ];

        const loadSounds = async () => {
            if (Capacitor.isNativePlatform()) {
                // Native: Preload SFX
                for (const sound of sounds) {
                    try {
                        try { await NativeAudio.unload({ assetId: sound }); } catch(e){}
                        await NativeAudio.preload({
                            assetId: sound,
                            assetPath: `public/sounds/${sound}.mp3`,
                            audioChannelNum: 1,
                            isUrl: false
                        });
                    } catch (e) { 
                        console.error(`NativeAudio preload failed for ${sound}:`, e); 
                    }
                }
                
                // Native: Preload BGM
                const bgms = ['bgm_peace', 'bgm_tense', 'bgm_danger'];
                for (const bgm of bgms) {
                     try {
                        try { await NativeAudio.unload({ assetId: bgm }); } catch(e){}
                        await NativeAudio.preload({
                            assetId: bgm,
                            assetPath: `public/sounds/${bgm}.mp3`,
                            audioChannelNum: 1,
                            isUrl: false
                        });
                    } catch (e) { 
                        console.error(`NativeAudio preload BGM failed for ${bgm}:`, e);
                    }
                }
                setAudioLoaded(true); // Signal completion

            } else {
                // Web: Preload using HTML5 Audio
                sounds.forEach(sound => {
                    const audio = new Audio(`/sounds/${sound}.mp3`);
                    audio.volume = 0.6;
                    webAudioRefs.current[sound] = audio;
                });
                setAudioLoaded(true);
            }
        };

        loadSounds();

        return () => {
            if (Capacitor.isNativePlatform()) {
                sounds.forEach(sound => NativeAudio.unload({ assetId: sound }).catch(() => {}));
                ['bgm_peace', 'bgm_tense', 'bgm_danger'].forEach(bgm => NativeAudio.unload({ assetId: bgm }).catch(() => {}));
            }
            if (bgmRef.current) { bgmRef.current.pause(); bgmRef.current = null; }
        };
    }, []);

    // --- Visual Theme Logic (Separated from Audio) ---
    useEffect(() => {
        // HPê°€ 0 ì´í•˜ì´ë©´ ì²˜ë¦¬ëŠ” í•˜ë˜, í…Œë§ˆëŠ” ìœ ì§€í•˜ê±°ë‚˜ ë³„ë„ ì²˜ë¦¬ ê°€ëŠ¥
        // ì—¬ê¸°ì„œëŠ” HPì— ë”°ë¼ ë°°ê²½ë§Œ ì¦‰ì‹œ ë³€ê²½
        const percentage = (hp / 1000000) * 100;
        
        // Remove old themes first
        document.documentElement.classList.remove('dark-theme', 'tense-theme');
        document.body.classList.remove('dark-theme', 'tense-theme');

        if (percentage < 20 && hp > 0) {
            document.documentElement.classList.add('dark-theme');
            document.body.classList.add('dark-theme');
        } else if (percentage < 70 && hp > 0) {
            document.documentElement.classList.add('tense-theme');
            document.body.classList.add('tense-theme');
        }
    }, [hp]);

    // --- Audio Logic (BGM) ---
    useEffect(() => {
        if (!audioLoaded) return; // Wait for load

        if (!isBgmOn || hp <= 0) {
            // ì†Œë¦¬ ë„ê¸° ë˜ëŠ” ì‚¬ë§ ì‹œ
            if (currentPhaseRef.current !== 'none') {
                stopBgm();
                currentPhaseRef.current = 'none';
            }
            return;
        }

        const percentage = (hp / 1000000) * 100;
        let newPhase = 'peace';
        if (percentage < 20) newPhase = 'danger';
        else if (percentage < 70) newPhase = 'tense';

        if (newPhase !== currentPhaseRef.current) {
            playBgm(newPhase);
            currentPhaseRef.current = newPhase;
        }
    }, [hp, isBgmOn, audioLoaded]);

    const stopBgm = async () => {
        if (Capacitor.isNativePlatform()) {
            try {
                await NativeAudio.stop({ assetId: 'bgm_peace' });
                await NativeAudio.stop({ assetId: 'bgm_tense' });
                await NativeAudio.stop({ assetId: 'bgm_danger' });
            } catch(e) {}
        } else {
            if (bgmRef.current) {
                bgmRef.current.pause();
                bgmRef.current = null;
            }
        }
    };

    const playBgm = async (phase) => {
        const trackName = `bgm_${phase}`;
        
        // Ensure previous BGM is fully stopped and cleared
        if (!Capacitor.isNativePlatform()) {
             if (bgmRef.current) {
                 bgmRef.current.pause();
                 bgmRef.current.currentTime = 0;
                 bgmRef.current.src = ""; // Detach
                 bgmRef.current = null;
             }
        } else {
             await stopBgm();
        }

        if (Capacitor.isNativePlatform()) {
            try {
                await NativeAudio.setVolume({ assetId: trackName, volume: 0.8 });
                await NativeAudio.play({ assetId: trackName });
                await NativeAudio.loop({ assetId: trackName });
            } catch(e) { 
                console.log("BGM Play/Loop Error:", e);
            }
        } else {
            const audio = new Audio(`/sounds/${trackName}.mp3`);
            audio.loop = true;
            audio.volume = 0.5;
            audio.play().catch(e => console.log("Web BGM play failed", e));
            bgmRef.current = audio;
        }
    };
    
    // --- Helper to resume Audio Context on Web ---
    const checkWebAudioAutoplay = () => {
        if (!Capacitor.isNativePlatform() && isBgmOn && bgmRef.current && bgmRef.current.paused) {
            bgmRef.current.play().catch(e => console.log("Still blocked", e));
        }
    };

    const toggleSound = () => {
        setIsSoundOn(prev => {
            const newState = !prev;
            localStorage.setItem('soundOn', JSON.stringify(newState));
            return newState;
        });
    };

    const toggleBgm = () => {
        setIsBgmOn(prev => {
            const newState = !prev;
            localStorage.setItem('bgmOn', JSON.stringify(newState));
            return newState;
        });
    };

    const playToolSound = async (tool) => {
        if (!isSoundOn) return;
        const soundName = tool || 'fist';

        if (Capacitor.isNativePlatform()) {
            try {
                await NativeAudio.play({ assetId: soundName });
            } catch (e) {
                // console.error("Native play error", e);
            }
        } else {
            const audio = webAudioRefs.current[soundName];
            if (audio) {
                audio.currentTime = 0;
                audio.play().catch(e => console.log('Web Audio play failed', e));
            }
        }
    };

    // --- Vibration State (Persisted in localStorage) ---
    const [isVibrationOn, setIsVibrationOn] = useState(() => {
        const saved = localStorage.getItem('vibrationOn');
        return saved !== null ? JSON.parse(saved) : true;
    });

    const toggleVibration = () => {
        setIsVibrationOn(prev => {
            const newState = !prev;
            localStorage.setItem('vibrationOn', JSON.stringify(newState));
            if (newState) {
                // Test vibration when turning on
                Haptics.impact({ style: ImpactStyle.Light });
            }
            return newState;
        });
    };

    const triggerVibration = async () => {
        if (isVibrationOn) {
            try {
                await Haptics.impact({ style: ImpactStyle.Medium });
            } catch (e) {
                // Ignore errors (e.g., if running on web without support)
            }
        }
    };

    // Track if I was a player in this round
    useEffect(() => {
        // If HP is full (New Round), reset
        if (serverState?.hp === serverState?.maxHp) {
             wasActivePlayer.current = false;
             setShowWinnerClaiming(false);
             setLocalLoserTimer(null);
        }
        // If I am a player while game is playing, mark as active
        if (connected && !isSpectating && hp > 0) {
            wasActivePlayer.current = true;
        }
    }, [serverState, isSpectating, hp, connected]);

    // Loser Timer Logic
    useEffect(() => {
        if (serverState?.status === 'WINNER_CHECK' && serverState?.winningClientId !== clientId && wasActivePlayer.current) {
            if (localLoserTimer === null) {
                setLocalLoserTimer(7); // Start 7s countdown
            } else if (localLoserTimer > 0) {
                const timer = setTimeout(() => setLocalLoserTimer(prev => prev - 1), 1000);
                return () => clearTimeout(timer);
            } else {
                // Timer finished
                setShowWinnerClaiming(true);
            }
        } else if (serverState?.status === 'WINNER_CHECK' && !wasActivePlayer.current) {
            // Pure spectator sees claiming screen immediately
            setShowWinnerClaiming(true);
        }
    }, [serverState, clientId, localLoserTimer, wasActivePlayer]);

    // Helper to format seconds to mm:ss
    const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m}:${s < 10 ? '0' : ''}${s}`;
    };

    const handlePointerDown = (e) => {
        // Only allow click if connected and playing
        if (!connected) return; 

        // 0. Trigger Vibration & Sound & Check Autoplay
        checkWebAudioAutoplay();
        triggerVibration();
        playToolSound(currentTool);

        // 1. Trigger Game Logic
        handleClick();

        // 2. Visuals: Calculate position relative to the stage
        if (!stageRef.current) return;
        const rect = stageRef.current.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Determine scale based on tool
        let scale = 1;
        let toolSize = 2; 
        switch(currentTool) {
            case 'hammer': scale = 1.2; toolSize = 2.5; break;
            case 'pickaxe': scale = 1.5; toolSize = 3.5; break;
            case 'dynamite': scale = 2.0; toolSize = 5.0; break;
            case 'drill': scale = 2.5; toolSize = 7.0; break;
            case 'excavator': scale = 3.0; toolSize = 10.0; break;
            case 'laser': scale = 4.0; toolSize = 14.0; break;
            case 'nuke': scale = 6.0; toolSize = 20.0; break;
            default: scale = 1; toolSize = 2;
        }

        // Random Cute Particle
        const randomParticle = CUTE_PARTICLES[Math.floor(Math.random() * CUTE_PARTICLES.length)];

        const newEffect = { 
            id: Date.now() + Math.random(), 
            x, 
            y, 
            val: clickPower,
            scale,
            toolSize,
            toolEmoji: TOOL_EMOJIS[currentTool] || 'ðŸ‘Š',
            particle: randomParticle
        };

        // 3. Add to state (Limit concurrent particles for optimization)
        setClickEffects(prev => {
            const next = [...prev, newEffect];
            if (next.length > 20) return next.slice(next.length - 20); // Keep max 20
            return next;
        });

        // 4. Cleanup after animation (800ms matches CSS)
        setTimeout(() => {
            setClickEffects(prev => prev.filter(item => item.id !== newEffect.id));
        }, 800);
    };
    
    // --- Render Conditions ---
    const isMyWin = serverState?.winningClientId === clientId;
    const isWinnerCheck = serverState?.status === 'WINNER_CHECK';
    const isFinished = serverState?.status === 'FINISHED';
    
    // Queue Display (If connected but spectating due to full room)
    const isInQueue = connected && isSpectating && !isWinnerCheck && !isFinished;

    return (
        <main className="game-area">
            {/* Queue Overlay */}
            {isInQueue && (
                 <div className="modal-overlay">
                    <div className="modal-content glass" style={{ textAlign: 'center', padding: '40px' }}>
                        <div style={{ fontSize: '4rem', marginBottom: '20px' }}>â³</div>
                        <h1 style={{ color: '#ff6f61', marginBottom: '10px' }}>ëŒ€ê¸°ì—´ ëŒ€ê¸° ì¤‘...</h1>
                        <p style={{ fontSize: '1.2rem' }}>ìž ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.</p>
                        <div className="spinner" style={{
                            width: '30px', height: '30px', border: '4px solid #ffe4e1', borderTop: '4px solid #ff6f61', 
                            borderRadius: '50%', animation: 'spin 1s linear infinite', margin: '20px auto'
                        }}></div>
                    </div>
                </div>
            )}
            {notification && (
                <div style={{
                    position: 'absolute',
                    top: '10%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)',
                    background: 'rgba(255, 255, 255, 0.95)',
                    color: '#ff6f61',
                    border: '3px solid #ffb6c1',
                    padding: '12px 30px',
                    borderRadius: '50px',
                    fontWeight: '800',
                    fontSize: '1.2rem',
                    zIndex: 200,
                    pointerEvents: 'none',
                    animation: 'bounceIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards',
                    boxShadow: '0 8px 20px rgba(255, 105, 180, 0.3)',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '10px',
                    whiteSpace: 'nowrap'
                }}>
                    <span style={{fontSize: '1.5rem'}}>ðŸ›ï¸</span> {notification}
                </div>
            )}

            {/* Gear Icon (Toggle Settings) */}
            <button 
                onClick={() => setIsSettingsOpen(!isSettingsOpen)}
                style={{
                    position: 'absolute',
                    top: '20px',
                    right: '20px',
                    width: '45px',
                    height: '45px',
                    borderRadius: '50%',
                    border: '2px solid rgba(255,255,255,0.8)',
                    background: 'rgba(255,255,255,0.4)',
                    backdropFilter: 'blur(5px)',
                    color: '#5d4037',
                    fontSize: '1.5rem',
                    cursor: 'pointer',
                    zIndex: 51,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    boxShadow: '0 4px 10px rgba(0,0,0,0.1)',
                    transition: 'transform 0.2s'
                }}
            >
                âš™ï¸
            </button>

            {/* Settings Box (Conditionally Rendered) */}
            {isSettingsOpen && (
                <div style={{
                    position: 'absolute',
                    top: '75px', // Below the gear icon
                    right: '20px',
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '15px',
                    zIndex: 50,
                    background: 'rgba(255, 255, 255, 0.85)',
                    padding: '20px',
                    borderRadius: '20px',
                    backdropFilter: 'blur(10px)',
                    boxShadow: '0 10px 40px rgba(0,0,0,0.15)',
                    border: '1px solid rgba(255,255,255,0.9)',
                    minWidth: '150px',
                    animation: 'popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)'
                }}>
                    {/* Sound Toggle */}
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                        <span style={{ fontSize: '1rem', fontWeight: 'bold', color: '#5d4037' }}>íš¨ê³¼ìŒ</span>
                        <div 
                            onClick={toggleSound}
                            style={{
                                width: '50px',
                                height: '28px',
                                background: isSoundOn ? '#ff9a9e' : '#e0e0e0',
                                borderRadius: '30px',
                                position: 'relative',
                                cursor: 'pointer',
                                transition: 'background 0.3s'
                            }}
                        >
                            <div style={{
                                width: '24px',
                                height: '24px',
                                background: '#fff',
                                borderRadius: '50%',
                                position: 'absolute',
                                top: '2px',
                                left: isSoundOn ? '24px' : '2px',
                                transition: 'left 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
                                boxShadow: '0 2px 5px rgba(0,0,0,0.2)'
                            }} />
                        </div>
                    </div>

                    {/* BGM Toggle */}
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                        <span style={{ fontSize: '1rem', fontWeight: 'bold', color: '#5d4037' }}>ë°°ê²½ìŒ</span>
                        <div 
                            onClick={toggleBgm}
                            style={{
                                width: '50px',
                                height: '28px',
                                background: isBgmOn ? '#ff9a9e' : '#e0e0e0',
                                borderRadius: '30px',
                                position: 'relative',
                                cursor: 'pointer',
                                transition: 'background 0.3s'
                            }}
                        >
                            <div style={{
                                width: '24px',
                                height: '24px',
                                background: '#fff',
                                borderRadius: '50%',
                                position: 'absolute',
                                top: '2px',
                                left: isBgmOn ? '24px' : '2px',
                                transition: 'left 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
                                boxShadow: '0 2px 5px rgba(0,0,0,0.2)'
                            }} />
                        </div>
                    </div>

                    {/* Vibration Toggle */}
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                        <span style={{ fontSize: '1rem', fontWeight: 'bold', color: '#5d4037' }}>ì§„ë™</span>
                        <div 
                            onClick={toggleVibration}
                            style={{
                                width: '50px',
                                height: '28px',
                                background: isVibrationOn ? '#ff9a9e' : '#e0e0e0',
                                borderRadius: '30px',
                                position: 'relative',
                                cursor: 'pointer',
                                transition: 'background 0.3s'
                            }}
                        >
                            <div style={{
                                width: '24px',
                                height: '24px',
                                background: '#fff',
                                borderRadius: '50%',
                                position: 'absolute',
                                top: '2px',
                                left: isVibrationOn ? '24px' : '2px',
                                transition: 'left 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
                                boxShadow: '0 2px 5px rgba(0,0,0,0.2)'
                            }} />
                        </div>
                    </div>
                </div>
            )}

            {/* Debug Console Removed */}
            
            <div className="header-glow">
                <h1 className="title">{lang.title}</h1>
                <p className="subtitle">{lang.subtitle}</p>
            </div>

            <div 
                className="egg-stage" 
                ref={stageRef}
                /* onPointerDown removed here for precise hitbox */
            >
                <CrackedEgg 
                    hp={hp} 
                    maxHp={1000000} 
                    isShaking={isShaking} 
                    tool={currentTool} 
                    onEggClick={handlePointerDown} 
                />

                {showGuide && (
                    <div style={{
                        position: 'absolute',
                        top: '50%',
                        left: '50%',
                        transform: 'translate(-50%, -50%)',
                        background: 'rgba(255, 255, 255, 0.9)',
                        padding: '15px 25px',
                        borderRadius: '20px',
                        boxShadow: '0 0 20px rgba(0,0,0,0.1)',
                        zIndex: 100,
                        fontWeight: 'bold',
                        color: '#ff6f61',
                        pointerEvents: 'none',
                        animation: 'pulse 1s infinite',
                        border: '2px solid #ffb6c1'
                    }}>
                        ê°€ìš´ë° ê³„ëž€ì„ ðŸ‘ˆ  í„°ì¹˜í•˜ì„¸ìš”!
                    </div>
                )}
                
                {/* Render Multiple Click Effects (Damage + Tool Icon + Cute Particle) */}
                {clickEffects.map(effect => (
                    <React.Fragment key={effect.id}>
                        {/* Damage Number */}
                        <span 
                            className="damage-float"
                            style={{ 
                                left: effect.x, 
                                top: effect.y - 50,
                                fontSize: `${1.8 * effect.scale}rem`,
                                fontWeight: '900',
                                color: '#ff6f61',
                                WebkitTextStroke: '2px #fff',
                                pointerEvents: 'none',
                                zIndex: 12,
                                transform: `rotate(${Math.random() * 20 - 10}deg)`
                            }}
                        >
                            -{effect.val}
                        </span>
                        
                        {/* Tool Icon */}
                        <span 
                            className="tool-float"
                            style={{ 
                                left: effect.x, 
                                top: effect.y,
                                fontSize: `${effect.toolSize}rem`,
                                position: 'absolute',
                                transform: 'translate(-50%, -50%)',
                                pointerEvents: 'none',
                                zIndex: 11,
                                animation: 'toolPop 0.5s ease-out forwards'
                            }}
                        >
                            {effect.toolEmoji}
                        </span>

                        {/* Extra Cute Particle */}
                        <span 
                            className="particle-float"
                            style={{ 
                                left: effect.x + (Math.random() * 40 - 20), 
                                top: effect.y + (Math.random() * 40 - 20),
                                fontSize: `${1.5 + Math.random()}rem`,
                                position: 'absolute',
                                transform: 'translate(-50%, -50%)',
                                pointerEvents: 'none',
                                zIndex: 10,
                                animation: 'particlePop 0.8s ease-out forwards'
                            }}
                        >
                            {effect.particle}
                        </span>
                    </React.Fragment>
                ))}

            {/* Unified Modal Logic */}
            {(isWinnerCheck || isFinished || showRetry) && (
                <div className="modal-overlay">
                    <div className="modal-content glass" style={{ maxWidth: '500px', width: '90%', display: 'flex', flexDirection: 'column', alignItems: 'center', textAlign: 'center', padding: '40px' }}>
                        
                        {/* 1. FINISHED State (Round Over, Waiting for Admin) */}
                        {isFinished && (
                            <>
                                <div style={{ fontSize: '4rem', marginBottom: '15px' }}>ðŸ</div>
                                <h2 style={{ color: '#ff6f61', fontSize: '2rem', marginBottom: '10px' }}>{lang.roundOverTitle}</h2>
                                <p style={{ color: '#5d4037', fontSize: '1.1rem', marginBottom: '25px', lineHeight: '1.6' }}>
                                    {lang.roundOverDesc} <br/> (ë‹¤ìŒ ë¼ìš´ë“œ ì¤€ë¹„ ì¤‘)
                                </p>
                            </>
                        )}

                        {/* 2. WINNER CHECK State */}
                        {isWinnerCheck && (
                            <>
                                {isMyWin ? (
                                    // A. I AM THE WINNER
                                    <>
                                        <h2 style={{ color: '#ff6f61', fontSize: '2rem', marginBottom: '10px' }}>{lang.modalTitle}</h2>
                                        <p style={{ fontSize: '1.1rem', lineHeight: '1.5', marginBottom: '20px' }}>{lang.modalDesc}</p>
                                        
                                        <div style={{ background: '#fff0f5', padding: '15px', borderRadius: '10px', marginBottom: '20px', border: '2px solid #ffb6c1', width: '100%' }}>
                                            <p style={{ color: '#d32f2f', fontWeight: 'bold', marginBottom: '5px' }}>âš ï¸ {lang.winnerTimerWarning}</p>
                                            <p style={{ fontSize: '1.5rem', fontWeight: '900', color: '#d32f2f' }}>
                                                {lang.timeLeft}: {formatTime(winnerCountdown)}
                                            </p>
                                        </div>

                                        {!emailSubmitted ? (
                                            <>
                                                <div style={{ background: 'rgba(255, 182, 193, 0.2)', padding: '20px', borderRadius: '15px', marginBottom: '20px', width: '100%' }}>
                                                    <p style={{ margin: '0 0 10px 0', color: '#ff6f61', fontWeight: 'bold' }}>{lang.modalPrize}</p>
                                                    <input 
                                                        type="email" 
                                                        placeholder="example@email.com"
                                                        value={winnerEmail}
                                                        onChange={(e) => setWinnerEmail(e.target.value)}
                                                        style={{ width: '90%', padding: '12px', borderRadius: '10px', border: '2px solid #ffe4e1', background: '#fff', color: '#5d4037', textAlign: 'center', fontSize: '1rem' }}
                                                    />
                                                </div>
                                                <button className="send-btn" onClick={submitWinnerEmail} style={{ fontSize: '1.1rem', padding: '12px 40px' }}>
                                                    {lang.send}
                                                </button>
                                            </>
                                        ) : (
                                            <h2 style={{ color: '#4CAF50', marginTop: '20px' }}>âœ… {lang.sent}</h2>
                                        )}
                                    </>
                                ) : (
                                    // B. I AM NOT THE WINNER (Loser or Spectator)
                                    <>
                                        {(!showWinnerClaiming && localLoserTimer !== null) ? (
                                            // Loser Timer Phase (7s)
                                            <>
                                                <div style={{ fontSize: '4rem', marginBottom: '10px' }}>ðŸ˜¢</div>
                                                <h2 style={{ color: '#5d4037', marginBottom: '15px' }}>
                                                    {lang.loserMsg?.split('.')[0] || "ì•„ì‰½ê²Œë„ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."} 
                                                </h2>
                                                <p style={{fontSize: '1.5rem', fontWeight: 'bold', color: '#ff6f61'}}>
                                                    {localLoserTimer}ì´ˆ í›„ ëŒ€ê¸°ì—´ë¡œ ì´ë™í•©ë‹ˆë‹¤.
                                                </p>
                                            </>
                                        ) : (
                                            // Winner Claiming Phase (Waiting)
                                            <>
                                                 <div className="spinner" style={{
                                                    width: '40px', height: '40px', border: '5px solid #ffe4e1', borderTop: '5px solid #ff6f61', borderRadius: '50%', animation: 'spin 1s linear infinite', marginBottom: '20px'
                                                }}></div>
                                                <h2>ðŸ† ìŠ¹ìžê°€ ìƒí’ˆì„ ìˆ˜ë ¹í•˜ê³  ìžˆìŠµë‹ˆë‹¤...</h2>
                                                <p>ìž ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.</p>
                                            </>
                                        )}
                                    </>
                                )}
                            </>
                        )}
                    </div>
                </div>
            )}
            </div>

            <div className="hp-wrapper">
                <div className="hp-container">
                    <div className="hp-bar" style={{ width: `${(hp / 1000000) * 100}%` }}></div>
                </div>
                <div className="hp-text">{hp.toLocaleString()} HP</div>
            </div>

            <button className="power-btn" onClick={handleAdWatch}>
                <span className="btn-title">{lang.adWatchBtn}</span>
                <span className="btn-sub">{lang.adReward}</span>
            </button>

            <div style={{
                fontSize: '8px', 
                color: 'rgba(0,0,0,0.4)', 
                textAlign: 'center', 
                marginBottom: '15px',
                marginTop: '-10px',
                pointerEvents: 'none'
            }}>
                ì´ í¬ìŠ¤íŒ…ì€ ì¿ íŒ¡ íŒŒíŠ¸ë„ˆìŠ¤ í™œë™ì˜ ì¼í™˜ìœ¼ë¡œ, ì´ì— ë”°ë¥¸ ì¼ì •ì•¡ì˜ ìˆ˜ìˆ˜ë£Œë¥¼ ì œê³µë°›ìŠµë‹ˆë‹¤
            </div>

          <div className="status-row glass">
            <div>{lang.myPoint}: <span>{myPoints}</span></div>
            <div>{lang.atk}: <span>x{clickPower}</span></div>
          </div>

          <p style={{
            marginTop: '20px',
            fontSize: '1.1rem',
            color: '#ff4444',
            fontWeight: '900',
            textAlign: 'center',
            background: 'rgba(255, 255, 255, 0.8)',
            padding: '10px 20px',
            borderRadius: '20px',
            border: '2px solid #ffcccc',
            boxShadow: '0 4px 10px rgba(255, 0, 0, 0.1)',
            cursor: 'pointer',
            animation: 'pulse 1.5s infinite'
          }} onClick={() => document.querySelector('.mobile-toggle-btn[aria-label="Shop"]')?.click()}>
            ðŸš¨ {lang.shopGuide} ðŸš¨
          </p>
        </main>
    );
};

export default GameArea;
[FILE_CONTENT_END:egg-breaker/src/components/GameArea.jsx]

// --- FILE: egg-breaker/src/components/LeftPanel.jsx (User & Stats Panel) ---
/*
  Left side panel displaying:
  - MVP Card (Highest Attack, Points, Clicks).
  - Server Status (Active players, Queue, Spectators).
  - Total online count.
  - Game rules and notices.
*/
[FILE_CONTENT_START:egg-breaker/src/components/LeftPanel.jsx]
import React, { useState, useRef } from 'react';

const LeftPanel = ({ lang, serverState, countryStats, onlineUsersCount, recentWinners, prize, prizeUrl, getFlagEmoji, isOpen, toggleMobilePanel }) => {
  
  const maxAtk = serverState?.maxAtk || 0;
  const maxAtkCountry = serverState?.maxAtkCountry || "UN";
  const hasRecord = maxAtk > 1; 

  const onlinePlayers = serverState?.onlinePlayers || 0;
  const waitingCount = serverState?.queueLength || 0;
  const spectators = serverState?.onlineSpectatorsApprox || 0;

  // ... (Swipe and Render logic follows)
  // [Full code omitted for brevity in summary, included in text file]
[FILE_CONTENT_START:egg-breaker/src/components/LeftPanel.jsx]
import React, { useState, useRef } from 'react';

const LeftPanel = ({ lang, serverState, countryStats, onlineUsersCount, recentWinners, prize, prizeUrl, getFlagEmoji, isOpen, toggleMobilePanel }) => {
  
  const maxAtk = serverState?.maxAtk || 0;
  const maxAtkCountry = serverState?.maxAtkCountry || "UN";
  const hasRecord = maxAtk > 1; 

  const onlinePlayers = serverState?.onlinePlayers || 0;
  const waitingCount = serverState?.queueLength || 0;
  const spectators = serverState?.onlineSpectatorsApprox || 0;

  // --- Swipe Logic ---
  const [translateY, setTranslateY] = useState(0);
  const touchStartY = useRef(0);
  const isDragging = useRef(false);

  const handleTouchStart = (e) => {
    touchStartY.current = e.touches[0].clientY;
    isDragging.current = true;
  };

  const handleTouchMove = (e) => {
    if (!isDragging.current) return;
    const currentY = e.touches[0].clientY;
    const diff = currentY - touchStartY.current;
    if (diff > 0) { // Only allow dragging down
        setTranslateY(diff);
    }
  };

  const handleTouchEnd = () => {
    isDragging.current = false;
    if (translateY > 100) { // Threshold to close
        toggleMobilePanel('none');
    }
    setTranslateY(0); // Reset position (if closed, CSS transition handles it)
  };

  return (
    <aside 
        className={`panel left-panel glass ${isOpen ? 'active' : ''}`} 
        style={{ 
            overflowY: 'auto',
            transform: isOpen ? `translateY(${translateY}px)` : undefined, 
            transition: isDragging.current ? 'none' : 'transform 0.4s cubic-bezier(0.33, 1, 0.68, 1)' 
        }}
    >
      <div 
        className="panel-header"
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
        style={{ cursor: 'grab', touchAction: 'none' }}
      >
        <h3 style={{ color: '#ff6f61' }}>{lang.users}</h3>
        <button className="panel-close-btn" onClick={() => toggleMobilePanel('none')}>Ã—</button>
      </div>
      
      {/* MVP Card */}
      <div style={{ 
          background: '#fff0f5', 
          borderRadius: '20px', 
          padding: '20px', 
          textAlign: 'center', 
          marginBottom: '20px',
          boxShadow: '0 4px 15px rgba(255, 111, 97, 0.1)'
      }}>
          <h4 style={{ margin: '0 0 10px 0', color: '#ff6f61', fontSize: '1rem' }}>
             ðŸ‘‘ {lang.maxAtkTitle || "Highest Attack"}
          </h4>
          
          <div style={{ fontSize: '2.5rem', marginBottom: '5px' }}>
              {hasRecord ? getFlagEmoji(maxAtkCountry) : 'ðŸ³ï¸'}
          </div>
          {/* Country Name removed as requested */}
          <div style={{ fontSize: '2rem', fontWeight: '900', color: '#ff9a9e', margin: '5px 0' }}>
              {hasRecord ? maxAtk.toLocaleString() : "1"}
          </div>
          
          {/* Max Points & Clicks */}
          <div style={{ display: 'flex', justifyContent: 'space-around', marginTop: '15px', borderTop: '1px solid rgba(0,0,0,0.05)', paddingTop: '10px' }}>
             <div>
                <div style={{ fontSize: '0.8rem', color: '#a1887f', fontWeight: 'bold' }}>{lang.maxPointTitle || "Max Points"}</div>
                <div style={{ fontSize: '1.1rem', color: '#ffb74d', fontWeight: '900' }}>
                    {serverState?.maxPoints ? serverState.maxPoints.toLocaleString() : "0"}
                </div>
             </div>
             <div>
                <div style={{ fontSize: '0.8rem', color: '#a1887f', fontWeight: 'bold' }}>{lang.maxClickTitle || "Max Clicks"}</div>
                <div style={{ fontSize: '1.1rem', color: '#8d6e63', fontWeight: '900' }}>
                    {serverState?.maxClicks ? serverState.maxClicks.toLocaleString() : "0"}
                </div>
             </div>
          </div>
      </div>

      {/* Server Status */}
      <h4 style={{ color: '#ff6f61', marginLeft: '5px', marginBottom: '10px' }}>
          ðŸ“Š {lang.serverStatusTitle || "Server Status"}
      </h4>
      
      <div style={{ display: 'flex', gap: '10px', marginBottom: '20px' }}>
          {/* Participants */}
          <div style={{ flex: 1, background: '#fff', padding: '15px 5px', borderRadius: '15px', textAlign: 'center', boxShadow: '0 2px 8px rgba(0,0,0,0.05)' }}>
              <div style={{ fontSize: '1.5rem', marginBottom: '5px' }}>âš”ï¸</div>
              <div style={{ fontSize: '0.8rem', color: '#5d4037', fontWeight: 'bold' }}>{lang.participants || "Active"}</div>
              <div style={{ fontSize: '1.2rem', color: '#ff6f61', fontWeight: '900' }}>{onlinePlayers}</div>
          </div>
          
          {/* Waiting */}
          <div style={{ flex: 1, background: '#fff', padding: '15px 5px', borderRadius: '15px', textAlign: 'center', boxShadow: '0 2px 8px rgba(0,0,0,0.05)' }}>
              <div style={{ fontSize: '1.5rem', marginBottom: '5px' }}>â³</div>
              <div style={{ fontSize: '0.8rem', color: '#5d4037', fontWeight: 'bold' }}>{lang.queueLabel || "Queue"}</div>
              <div style={{ fontSize: '1.2rem', color: '#ffb74d', fontWeight: '900' }}>{waitingCount}</div>
          </div>
          
          {/* Spectators */}
          <div style={{ flex: 1, background: '#fff', padding: '15px 5px', borderRadius: '15px', textAlign: 'center', boxShadow: '0 2px 8px rgba(0,0,0,0.05)' }}>
              <div style={{ fontSize: '1.5rem', marginBottom: '5px' }}>ðŸ‘€</div>
              <div style={{ fontSize: '0.8rem', color: '#5d4037', fontWeight: 'bold' }}>{lang.spectators || "Spectators"}</div>
              <div style={{ fontSize: '1.2rem', color: '#8d6e63', fontWeight: '900' }}>{spectators}</div>
          </div>
      </div>

      {/* Total Online Badge */}
      <div className="total-badge" style={{ 
          color: '#2e7d32', 
          background: '#e8f5e9', 
          border: 'none',
          borderRadius: '15px',
          padding: '15px',
          fontSize: '1.1rem',
          fontWeight: 'bold',
          marginBottom: '20px'
      }}>
        ðŸŸ¢ {lang.totalOnline || "Total Online"}: {onlineUsersCount.toLocaleString()}
      </div>

      <div className="rule-notice-box" style={{ padding: '15px', background: 'rgba(255, 255, 255, 0.5)', borderRadius: '15px', margin: '10px 0', fontSize: '0.85rem', textAlign: 'left' }}>
        <h4 style={{ margin: '0 0 8px 0', color: '#ff6f61' }}>ðŸ“œ {lang.gameRuleTitle}</h4>
        <ul style={{ paddingLeft: '20px', margin: '0 0 15px 0', color: '#5d4037', lineHeight: '1.4' }}>
          <li>{lang.gameRule1}</li>
          <li>{lang.gameRule2}</li>
          <li>{lang.gameRule3}</li>
        </ul>

        <h4 style={{ margin: '0 0 8px 0', color: '#ff6f61' }}>âš ï¸ {lang.noticeTitle}</h4>
        <ul style={{ paddingLeft: '20px', margin: 0, color: '#d32f2f', fontSize: '0.8rem', fontWeight: 'bold' }}>
          <li style={{ marginBottom: '5px' }}>{lang.notice1}</li>
          <li>{lang.notice2}</li>
        </ul>
      </div>

      <div className="info-box">
        <h4>{lang.contactTitle}</h4>
        <p>bbbofficial95@gmail.com</p>
      </div>
    </aside>
  );
};

export default LeftPanel;
[FILE_CONTENT_END:egg-breaker/src/components/LeftPanel.jsx]

// --- FILE: egg-breaker/src/components/RightPanel.jsx (Shop & Social) ---
/*
  Right side panel displaying:
  - Kakao/Social Share reward button.
  - Item Shop (Hammer, Pickaxe, etc.) with progressive costs and ATK bonuses.
  - User's current ATK and session total clicks.
*/
[FILE_CONTENT_START:egg-breaker/src/components/RightPanel.jsx]
import React, { useState, useRef } from 'react';

const RightPanel = ({ lang, buyItem, myPoints, clickPower, myTotalClicks, handleKakaoShare, isOpen, toggleMobilePanel }) => {
  // (Tool items definitions and Shop UI logic)
  // ... [Full Code follows below]
[FILE_CONTENT_START:egg-breaker/src/components/RightPanel.jsx]
import React, { useState, useRef } from 'react';

const RightPanel = ({ lang, buyItem, myPoints, clickPower, myTotalClicks, handleKakaoShare, isOpen, toggleMobilePanel }) => {
  const TOOL_ITEMS = [
    { id: 'item1', name: lang.item1, cost: 50, power: 1, icon: 'ðŸ”¨' },
    { id: 'item2', name: lang.item2, cost: 300, power: 5, icon: 'â›ï¸' },
    { id: 'item3', name: lang.item3, cost: 1000, power: 15, icon: 'ðŸ§¨' },
    { id: 'item4', name: lang.item4, cost: 3000, power: 40, icon: 'ðŸ”©' },
    { id: 'item5', name: lang.item5, cost: 8000, power: 100, icon: 'ðŸšœ' },
    { id: 'item6', name: lang.item6, cost: 20000, power: 250, icon: 'ðŸ”«' },
    { id: 'item7', name: lang.item7, cost: 50000, power: 600, icon: 'â˜¢ï¸' },
  ];

  // --- Swipe Logic ---
  const [translateY, setTranslateY] = useState(0);
  const touchStartY = useRef(0);
  const isDragging = useRef(false);

  const handleTouchStart = (e) => {
    touchStartY.current = e.touches[0].clientY;
    isDragging.current = true;
  };

  const handleTouchMove = (e) => {
    if (!isDragging.current) return;
    const currentY = e.touches[0].clientY;
    const diff = currentY - touchStartY.current;
    if (diff > 0) {
        setTranslateY(diff);
    }
  };

  const handleTouchEnd = () => {
    isDragging.current = false;
    if (translateY > 100) {
        toggleMobilePanel('none');
    }
    setTranslateY(0);
  };

  return (
    <aside 
        className={`panel right-panel glass ${isOpen ? 'active' : ''}`} 
        style={{ 
            overflowY: 'auto',
            transform: isOpen ? `translateY(${translateY}px)` : undefined,
            transition: isDragging.current ? 'none' : 'transform 0.4s cubic-bezier(0.33, 1, 0.68, 1)'
        }}
    >
      <div 
        className="panel-header"
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
        style={{ cursor: 'grab', touchAction: 'none' }}
      >
        <h3>{lang.shop}</h3>
        <button className="panel-close-btn" onClick={() => toggleMobilePanel('none')}>Ã—</button>
      </div>

      <button 
        onClick={handleKakaoShare}
        style={{
            width: '100%',
            background: '#FEE500',
            color: '#000000',
            border: 'none',
            padding: '12px',
            borderRadius: '8px',
            fontWeight: 'bold',
            marginBottom: '15px',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: '8px'
        }}
      >
        <span style={{fontSize: '1.2rem'}}>ðŸ’¬</span> 
        {lang.shareReward}
      </button>

      <div className="shop-list">
        <div className="shop-item" onClick={() => buyItem(500, 1, 'hammer')}>
          <div className="icon-box"><div className="icon">ðŸ”¨</div></div>
          <div className="info">
            <h4>{lang.item1}</h4>
            <div className="price">500 P <span style={{color:'#ff6f61', marginLeft:'5px', fontSize:'0.8em'}}>(+1 {lang.atk})</span></div>
          </div>
        </div>
        <div className="shop-item" onClick={() => buyItem(2500, 6, 'pickaxe')}>
          <div className="icon-box"><div className="icon">â›ï¸</div></div>
          <div className="info">
            <h4>{lang.item2}</h4>
            <div className="price">2.5k P <span style={{color:'#ff6f61', marginLeft:'5px', fontSize:'0.8em'}}>(+6 {lang.atk})</span></div>
          </div>
        </div>
        <div className="shop-item" onClick={() => buyItem(12000, 35, 'dynamite')}>
          <div className="icon-box"><div className="icon">ðŸ§¨</div></div>
          <div className="info">
            <h4>{lang.item3}</h4>
            <div className="price">12k P <span style={{color:'#ff6f61', marginLeft:'5px', fontSize:'0.8em'}}>(+35 {lang.atk})</span></div>
          </div>
        </div>
        <div className="shop-item" onClick={() => buyItem(60000, 200, 'drill')}>
          <div className="icon-box"><div className="icon">ðŸ”©</div></div>
          <div className="info">
            <h4>{lang.item4}</h4>
            <div className="price">60k P <span style={{color:'#ff6f61', marginLeft:'5px', fontSize:'0.8em'}}>(+200 {lang.atk})</span></div>
          </div>
        </div>
        <div className="shop-item" onClick={() => buyItem(300000, 1200, 'excavator')}>
          <div className="icon-box"><div className="icon">ðŸšœ</div></div>
          <div className="info">
            <h4>{lang.item5}</h4>
            <div className="price">300k P <span style={{color:'#ff6f61', marginLeft:'5px', fontSize:'0.8em'}}>(+1200 {lang.atk})</span></div>
          </div>
        </div>
        <div className="shop-item" onClick={() => buyItem(1500000, 7000, 'laser')}>
          <div className="icon-box"><div className="icon">ðŸ”«</div></div>
          <div className="info">
            <h4>{lang.item6}</h4>
            <div className="price">1.5M P <span style={{color:'#ff6f61', marginLeft:'5px', fontSize:'0.8em'}}>(+7000 {lang.atk})</span></div>
          </div>
        </div>
        <div className="shop-item" onClick={() => buyItem(10000000, 60000, 'nuke')}>
          <div className="icon-box"><div className="icon">â˜¢ï¸</div></div>
          <div className="info">
            <h4>{lang.item7}</h4>
            <div className="price">10M P <span style={{color:'#ff6f61', marginLeft:'5px', fontSize:'0.8em'}}>(+60000 {lang.atk})</span></div>
          </div>
        </div>
      </div>

      <div className="status-row glass">
        <div style={{width:'100%', textAlign:'center'}}>{lang.atk}: <span>x{clickPower}</span></div>
      </div>

      <div className="info-box">
        <h4>ðŸ“Š {lang.myInfoTitle}</h4>
        <p>
          {lang.totalClick}: {myTotalClicks}
        </p>
      </div>

    </aside>
  );
};

export default RightPanel;
[FILE_CONTENT_END:egg-breaker/src/components/RightPanel.jsx]
