
--- File: egg-breaker/src/App.jsx ---
import { useState, useEffect, useRef } from 'react';
import { NativeAudio } from '@capacitor-community/native-audio';
import { Capacitor } from '@capacitor/core';
import { useGameState } from './hooks/useGameState';
import { usePushNotifications } from './hooks/usePushNotifications';
import './App.css';
import Admin from './Admin';
import Header from './components/Header';
import LeftPanel from './components/LeftPanel';
import RightPanel from './components/RightPanel';
import InfoPanel from './components/InfoPanel';
import GameArea from './components/GameArea';

// --- ë‹¤êµ­ì–´ ë°ì´í„° (ìœ ì§€) ---
const TRANSLATIONS = {
  US: { 
    label: "English", title: "Egg Pong â˜ï¸", subtitle: "Pop! Let's crack this egg together!", users: "Live Users", total: "Total", shop: "Shop", myPoint: "Points", atk: "ATK", item1: "Dual Hammer", item2: "Pickaxe", item3: "TNT", item4: "Drill", item5: "Excavator", item6: "Laser Gun", item7: "Nuclear Bomb", modalTitle: "ğŸ‰ Congratulations! ğŸ‰", modalDesc: "You delivered the final blow and broke the egg! You are the Legendary Destroyer.", modalPrize: "Please enter your email address to receive the prize:", send: "Submit to Claim Prize", adText: "Ad Banner Area", powerClick: "âš¡ Power Click (+100) âš¡", watchAd: "Watch an Ad", logo: "Egg Pong â˜ï¸",
    gameRuleTitle: "How to Play", gameRule1: "- Click the egg to reduce its HP.", gameRule2: "- Collect points to buy items. The stronger you get, the greater the rewards!", gameRule3: "- Break the egg with the world!", noticeTitle: "Notice", notice1: "- Abnormal play may result in a ban.", notice2: "- This game may be reset.", prizeTitle: "Current Prize", contactTitle: "Contact", myInfoTitle: "My Info", totalClick: "Total Clicks",
    notEnoughPoints: "Points not enough!", alreadyShared: "You already received the share reward for this round!", shareSuccess: "Link shared! You will get 800P when your friend plays.", inviteSuccess: "Friend joined! You got 800 Points!", sent: "Sent successfully!", bought: "Bought",
    newRoundReset: "New Round Started! All progress has been reset.",
    shopGuide: "Click the shop on the right to get powerful items!",
    rivalryTitle: "TOP RIVALRY", gap: "Gap", waiting: "Waiting...", noRival: "No Rival",
    hallOfFame: "Menu", recentPrizes: "Recent Prizes", noRecords: "No records yet. Be the first winner!",
    adWatchBtn: "ğŸ“º Watch Ad (+2000P)", shareBtn: "ğŸ’¬ Share (+800P)",
    adReward: "+2000 Points", shareReward: "Share & Get 800P (Max 5)",
    roundOverTitle: "Round Over!", roundOverDesc: "Waiting for the next round to begin.",
    checkingWinnerTitle: "Checking Winner...", checkingWinnerDesc: "Please wait while we verify the legendary destroyer.",
    winnerTimerWarning: "You must enter your email within 5 minutes.", winnerExitMsg: "Sent! Exiting... (Opening new window)", loserMsg: "Unfortunately, you failed. Exiting... (Opening new window)", timeLeft: "Time Left",
    retryTitle: "Ready to try again?", retryBtn: "ğŸ”„ Re-enter Game",
    tapToClose: "(Tap to close)",
    maxAtkTitle: "Highest Attack", maxPointTitle: "Highest Points", maxClickTitle: "Highest Clicks", serverStatusTitle: "Server Status", participants: "Active", queueLabel: "Queue", spectators: "Spectators", totalOnline: "Total Online",
    soundOn: "SFX", bgmOn: "BGM", vibrationOn: "Vibrate", touchGuide: "Touch the egg in the middle! ğŸ‘ˆ",
    joinGame: "JOIN GAME", joinQueue: "Join Queue", fullServer: "Spectate Only (Full)",
    eggFacts: [
        "Did you know? An egg shell can have up to 17,000 pores!",
        "Tip: Use items to break the egg faster.",
        "Teamwork: Invite friends to deal more damage!",
        "World Record: The most eggs crushed with the head in one minute is 80.",
        "Fun Fact: Eggs contain every vitamin except Vitamin C."
    ]
  },
  KR: { 
    label: "í•œêµ­ì–´", title: "ì—ê·¸í â˜ï¸", subtitle: "ë‹¤í•¨ê»˜ í! ì „ì„¤ì˜ ì•Œ ê¹¨ê¸°", users: "ì ‘ì†ì", total: "ì´", shop: "ìƒì ", myPoint: "ë³´ìœ  í¬ì¸íŠ¸", atk: "ê³µê²©ë ¥", item1: "ìŒë§ì¹˜", item2: "ê³¡ê´­ì´", item3: "TNT í­ì•½", item4: "ë“œë¦´", item5: "í¬í¬ë ˆì¸", item6: "ë ˆì´ì € ì´", item7: "í•µí­íƒ„", modalTitle: "ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ğŸ‰", modalDesc: "ë§ˆì§€ë§‰ ì¼ê²©ì„ ê°€í•´ ì•Œì„ ê¹¨íŠ¸ë¦¬ì…¨ìŠµë‹ˆë‹¤! ë‹¹ì‹ ì´ ë°”ë¡œ ì „ì„¤ì˜ íŒŒê´´ìì…ë‹ˆë‹¤.", modalPrize: "ìƒí’ˆ ìˆ˜ë ¹ì„ ìœ„í•´ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”(ìƒˆë¡œê³ ì¹¨ì„ ëˆ„ë¥´ì§€ ë§ˆì„¸ìš”! ì´ˆê¸°í™”ë©ë‹ˆë‹¤.):", send: "ìƒí’ˆ ì‹ ì²­í•˜ê¸°", adText: "ê´‘ê³  ì˜ì—­", powerClick: "âš¡ íŒŒì›Œ í´ë¦­ (+100) âš¡", watchAd: "ê´‘ê³  ë³´ê³  ", logo: "ì—ê·¸í â˜ï¸",
    gameRuleTitle: "ê²Œì„ ë°©ë²•", gameRule1: "- í™”ë©´ì„ í´ë¦­í•˜ì—¬ ì•Œì˜ HPë¥¼ ì¤„ì´ì„¸ìš”.", gameRule2: "- í¬ì¸íŠ¸ë¥¼ ëª¨ì•„ ì•„ì´í…œì„ êµ¬ë§¤í•˜ë©´ ê³µê²©ë ¥ì´ ì˜¬ë¼ê°‘ë‹ˆë‹¤.", gameRule3: "- ë§ˆì§€ë§‰ ì¼ê²©ì„ ê°€í•œ ë‹¨ í•œ ëª…ì´ ìš°ìŠ¹ ìƒí’ˆì„ ì°¨ì§€í•©ë‹ˆë‹¤!", noticeTitle: "ì£¼ì˜ì‚¬í•­", notice1: "- ë¹„ì •ìƒì ì¸ í”Œë ˆì´ëŠ” ì œì¬ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.", notice2: "- ìƒˆë¡œê³ ì¹¨ ì‹œ ì´ˆê¸°í™”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.", prizeTitle: "ì´ë²ˆ íšŒì°¨ ìƒí’ˆ", contactTitle: "ì œíœ´ë¬¸ì˜", myInfoTitle: "ë‚´ ì •ë³´", totalClick: "ì´ í´ë¦­",
    notEnoughPoints: "í¬ì¸íŠ¸ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!", alreadyShared: "ì´ë²ˆ ë¼ìš´ë“œì—ëŠ” ì´ë¯¸ ê³µìœ  ë³´ìƒì„ ë°›ìœ¼ì…¨ìŠµë‹ˆë‹¤!", shareSuccess: "ë§í¬ ê³µìœ  ì™„ë£Œ! ì¹œêµ¬ê°€ ì ‘ì†í•˜ë©´ 800Pê°€ ì§€ê¸‰ë©ë‹ˆë‹¤.", inviteSuccess: "ì¹œêµ¬ê°€ ì ‘ì†í–ˆìŠµë‹ˆë‹¤! 800 í¬ì¸íŠ¸ë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!", sent: "ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤!", bought: "êµ¬ë§¤ ì™„ë£Œ:",
    newRoundReset: "ìƒˆë¡œìš´ ë¼ìš´ë“œê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤! ëª¨ë“  ì§„í–‰ ìƒí™©ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.",
    shopGuide: "ì—¬ê¸°ë¥¼ ëˆŒëŸ¬ ë” ê°•ë ¥í•œ ì•„ì´í…œì„ íšë“í•˜ì„¸ìš”",
    rivalryTitle: "êµ­ê°€ ëŒ€í•­ì „", gap: "ì°¨ì´", waiting: "ëŒ€ê¸°ì¤‘...", noRival: "ë¼ì´ë²Œ ì—†ìŒ",
    hallOfFame: "ìƒí’ˆ", recentPrizes: "ìµœê·¼ ìš°ìŠ¹ ìƒí’ˆ", noRecords: "ì•„ì§ ìš°ìŠ¹ìê°€ ì—†ìŠµë‹ˆë‹¤. ì²« ìš°ìŠ¹ìê°€ ë˜ì–´ë³´ì„¸ìš”!",
    adWatchBtn: "ğŸ“º ê´‘ê³  ë³´ê³  í¬ì¸íŠ¸ ë°›ê¸°(+2000P)", shareBtn: "ğŸ’¬ ê³µìœ í•˜ê¸° (+800P)",
    adReward: "", shareReward: "ì¹´í†¡ìœ¼ë¡œ ê³µìœ í•˜ê³  800P ë°›ê¸° (ìµœëŒ€ 5íšŒ)",
    roundOverTitle: "ë¼ìš´ë“œ ì¢…ë£Œ!", roundOverDesc: "ë‹¤ìŒ ë¼ìš´ë“œ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.",
    checkingWinnerTitle: "ìš°ìŠ¹ì íŒë… ì¤‘...", checkingWinnerDesc: "ëˆ„ê°€ ë§ˆì§€ë§‰ ì¼ê²©ì„ ë‚ ë ¸ëŠ”ì§€ í™•ì¸í•˜ê³  ìˆìŠµë‹ˆë‹¤.",
    winnerTimerWarning: "5ë¶„ ì•ˆì— ì´ë©”ì¼ì„ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤. (ë¯¸ì…ë ¥ ì‹œ ì·¨ì†Œ)", winnerExitMsg: "ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤! ì ì‹œ í›„ í‡´ì¥í•©ë‹ˆë‹¤", loserMsg: "ì•„ì‰½ê²Œë„ ì´ë²ˆì—ëŠ” ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ í‡´ì¥í•©ë‹ˆë‹¤ (ìƒˆ ì°½ ì—´ë¦¼)", timeLeft: "ë‚¨ì€ ì‹œê°„",
    retryTitle: "ë‹¤ì‹œ ë„ì „í•˜ì‹œê² ìŠµë‹ˆê¹Œ?", retryBtn: "ğŸ”„ ì¬ì…ì¥í•˜ê¸°",
    tapToClose: "(íƒ­í•˜ì—¬ ì—†ì• ê¸°)",
    maxAtkTitle: "ìµœê³  ê³µê²©ë ¥", maxPointTitle: "ìµœê³  í¬ì¸íŠ¸", maxClickTitle: "ìµœê³  í´ë¦­ìˆ˜", serverStatusTitle: "ì„œë²„ í˜„í™©", participants: "ì°¸ì—¬ì", queueLabel: "ëŒ€ê¸°ì", spectators: "êµ¬ê²½ê¾¼", totalOnline: "Total Online",
    soundOn: "íš¨ê³¼ìŒ", bgmOn: "ë°°ê²½ìŒ", vibrationOn: "ì§„ë™", touchGuide: "ê°€ìš´ë° ê³„ë€ì„ ğŸ‘ˆ í„°ì¹˜í•˜ì„¸ìš”!",
    joinGame: "ê²Œì„ ì°¸ê°€í•˜ê¸°", joinQueue: "ëŒ€ê¸°ì—´ ë“±ë¡", fullServer: "êµ¬ê²½í•˜ê¸° (ë§Œì›)",
    eggFacts: [
        "íŒ: ì•„ì´í…œì„ êµ¬ë§¤í•˜ë©´ ê³µê²©ë ¥ì´ ë¹„ì•½ì ìœ¼ë¡œ ìƒìŠ¹í•©ë‹ˆë‹¤!",
        "ìƒì‹: ê³„ë€ ê»ë°ê¸°ì—ëŠ” ì•½ 17,000ê°œì˜ ìˆ¨êµ¬ë©ì´ ìˆëŒ€ìš”.",
        "íŒ: ì¹œêµ¬ë¥¼ ì´ˆëŒ€í•˜ë©´ 800 í¬ì¸íŠ¸ë¥¼ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
        "ê¸°ë¡: 1ë¶„ì— ì´ë§ˆë¡œ ê³„ë€ 80ê°œë¥¼ ê¹¬ ì‚¬ëŒì´ ê¸°ë„¤ìŠ¤ë¶ì— ì˜¬ëëŒ€ìš”!",
        "ìƒì‹: ì‹ ì„ í•œ ê³„ë€ì€ ë¬¼ì— ê°€ë¼ì•‰ê³ , ì˜¤ë˜ëœ ê³„ë€ì€ ëœ¹ë‹ˆë‹¤.",
        "ì „ëµ: ë§ˆì§€ë§‰ 1% ë‚¨ì•˜ì„ ë•Œ ì§‘ì¤‘ ê³µê²©í•˜ì„¸ìš”!",
        "íŒ: ê´‘ê³ ë¥¼ ì‹œì²­í•˜ë©´ í° í¬ì¸íŠ¸ë¥¼ í•œ ë²ˆì— ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."
    ]
  },
  JP: { 
    label: "æ—¥æœ¬èª", title: "ã‚¨ãƒƒã‚°ãƒãƒ³ â˜ï¸", subtitle: "ä¸–ç•Œä¸­ã§ä¼èª¬ã®åµã‚’å‰²ã‚ã†", users: "æ¥ç¶šä¸­", total: "è¨ˆ", shop: "å•†åº—", myPoint: "ãƒã‚¤ãƒ³ãƒˆ", atk: "æ”»æ’ƒåŠ›", item1: "ãƒãƒ³ãƒãƒ¼", item2: "ã¤ã‚‹ã¯ã—", item3: "ãƒ€ã‚¤ãƒŠãƒì´íŠ¸", item4: "ãƒ‰ãƒªãƒ«", item5: "ã‚·ãƒ§ãƒ™ãƒ«ã‚«ãƒ¼", item6: "ãƒ¬ãƒ¼ã‚¶ãƒ¼éŠƒ", item7: "æ ¸çˆ†å¼¾", modalTitle: "ğŸ‰ ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼ ğŸ‰", modalDesc: "æœ€å¾Œã®ä¸€æ’ƒã§åµã‚’å‰²ã‚Šã¾ã—ãŸï¼ã‚ãªãŸãŒä¼èª¬ã®ç ´å£Šè€…ã§ã™ã€‚", modalPrize: "è³å“ã‚’å—ã‘å–ã‚‹ãŸã‚ã«ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š", send: "é€ä¿¡ã™ã‚‹", adText: "åºƒå‘Šã‚¨ãƒªã‚¢", powerClick: "âš¡ ãƒ‘ãƒ¯ãƒ¼ã‚¯ãƒªãƒƒã‚¯ (+100) âš¡", watchAd: "åºƒå‘Šã‚’è¦‹ã¦æ”»æ’ƒ", logo: "ã‚¨ãƒƒã‚°ãƒãƒ³ â˜ï¸",
    gameRuleTitle: "éŠã³æ–¹", gameRule1: "- åµã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦HPã‚’æ¸›ã‚‰ã—ã¦ãã ã•ã„ã€‚", gameRule2: "- ãƒã‚¤ãƒ³ãƒˆã‚’é›†ã‚ã¦ã‚¢ã‚¤ãƒ†ãƒ ã‚’è³¼å…¥ã—ã¾ã—ã‚‡ã†ã€‚", gameRule3: "- ä¸–ç•Œä¸­ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨ä¸€ç·’ã«åµã‚’å‰²ã‚Šã¾ã—ã‚‡ã†ï¼", noticeTitle: "æ³¨æ„äº‹é …", notice1: "- ä¸æ­£ãªãƒ—ãƒ¬ã‚¤ã¯åˆ¶è£ã®å¯¾è±¡ã¨ãªã‚Šã¾ã™ã€‚", notice2: "- ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã¯ãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚", prizeTitle: "ä»Šå›ã®è³å“", contactTitle: "ãŠå•ã„åˆã‚ã›", myInfoTitle: "ãƒã‚¤æƒ…å ±", totalClick: "ç·ã‚¯ãƒªãƒƒã‚¯æ•°",
    notEnoughPoints: "ãƒã‚¤ãƒ³ãƒˆê°€ è¶³ã‚Šã¾ã›ã‚“ï¼", alreadyShared: "ã“ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã®ã‚·ã‚§ã‚¢å ±é…¬ã¯æ—¢ã«å—ã‘å–ã£ã¦ã„ã¾ã™ï¼", shareSuccess: "ãƒªãƒ³ã‚¯ã‚’ã‚·ã‚§ã‚¢ã—ã¾ã—ãŸï¼å‹é”ãŒå‚åŠ ã™ã‚‹ã¨800Pã‚‚ã‚‰ãˆã¾ã™ã€‚", inviteSuccess: "å‹é”ãŒå‚åŠ ã—ã¾ã—ãŸï¼800ãƒã‚¤ãƒ³ãƒˆã‚’ç²å¾—ã—ã¾ã—ãŸï¼", sent: "é€ä¿¡ã—ã¾ã—ãŸï¼", bought: "è³¼å…¥å®Œäº†:",
    newRoundReset: "æ–°ã—ã„ãƒ©ã‚¦ãƒ³ãƒ‰ãŒå§‹ã¾ã‚Šã¾ã—ãŸï¼ã™ã¹ã¦ã®é€²è¡ŒçŠ¶æ³ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸã€‚",
    shopGuide: "å³ã®ã‚·ãƒ§ãƒƒãƒ—ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å¼·åŠ›ãªã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‰‹ã«å…¥ã‚Œã‚ˆã†ï¼",
    rivalryTitle: "å›½å®¶å¯¾æŠ—æˆ¦", gap: "å·®", waiting: "å¾…æ©Ÿä¸­...", noRival: "ãƒ©ã‚¤ãƒãƒ«ãªã—",
    hallOfFame: "ãƒ¡ãƒ‹ãƒ¥ãƒ¼", recentPrizes: "æœ€è¿‘ã®è³å“", noRecords: "ã¾ã å‹è€…ã¯ã„ã¾ã›ã‚“. æœ€åˆã®å‹è€…ã«ãªã‚ã†ï¼",
    adWatchBtn: "ğŸ“º åºƒå‘Šã‚’è¦‹ã‚‹ (+2000P)", shareBtn: "ğŸ’¬ ã‚·ã‚§ã‚¢ (+800P)",
    adReward: "+2000 ãƒã‚¤ãƒ³ãƒˆ", shareReward: "ã‚·ã‚§ã‚¢ã—ã¦800Pã‚²ãƒƒãƒˆ (æœ€å¤§5å›)",
    roundOverTitle: "ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†ï¼", roundOverDesc: "æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’å¾…æ©Ÿä¸­...",
    checkingWinnerTitle: "å‹è€…ã‚’åˆ¤å®šä¸­...", checkingWinnerDesc: "ä¼èª¬ã®ç ´å£Šè€…ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚",
    winnerTimerWarning: "5ë¶„ ì´ë‚´ì— ì…ë ¥í•´ì£¼ì„¸ìš”ã€‚", winnerExitMsg: "é€ä¿¡ã—ã¾ã—ãŸï¼ã¾ã‚‚ãªãçµ‚äº†ã—ã¾ã™ (æ–°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦)", loserMsg: "æ®‹å¿µãªãŒã‚‰å¤±æ•—ã—ã¾ã—ãŸ. ã¾ã‚‚ãªãçµ‚äº†ã—ã¾ã™ (æ–°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦)", timeLeft: "æ®‹ã‚Šæ™‚é–“",
    retryTitle: "ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã—ã¾ã™ã‹ï¼Ÿ", retryBtn: "ğŸ”„ ã‚²ãƒ¼ãƒ å†å…¥å ´",
    tapToClose: "(ã‚¿ãƒƒãƒ—ã—ã¦é–‰ã˜ã‚‹)",
    maxAtkTitle: "æœ€é«˜æ”»æ’ƒåŠ›", maxPointTitle: "æœ€é«˜ãƒã‚¤ãƒ³ãƒˆ", maxClickTitle: "æœ€é«˜ã‚¯ãƒªãƒƒã‚¯æ•°", serverStatusTitle: "ã‚µãƒ¼ãƒãƒ¼çŠ¶æ³", participants: "å‚åŠ è€…", queueLabel: "å¾…æ©Ÿä¸­", spectators: "è¦³æˆ¦è€…", totalOnline: "Total Online",
    soundOn: "åŠ¹æœéŸ³", bgmOn: "BGM", vibrationOn: "æŒ¯å‹•", touchGuide: "çœŸã‚“ä¸­ã®åµã‚’ ğŸ‘ˆ ã‚¿ãƒƒãƒã—ã¦ãã ã•ã„ï¼",
    joinGame: "ã‚²ãƒ¼ãƒ å‚åŠ ", joinQueue: "å¾…æ©Ÿåˆ—ç™»éŒ²", fullServer: "è¦³æˆ¦ã®ã¿ (æº€å“¡)",
    eggFacts: [
        "ãƒ’ãƒ³ãƒˆï¼šã‚¢ã‚¤ãƒ†ãƒ ã‚’è³¼å…¥ã™ã‚‹ã¨æ”»æ’ƒåŠ›ãŒå¤§å¹…ã«ä¸Šæ˜‡ã—ã¾ã™ï¼",
        "è±†çŸ¥è­˜ï¼šåµã®æ®»ã«ã¯ç´„17,000å€‹ã®æ°—å­”ãŒã‚ã‚‹ãã†ã§ã™ã€‚",
        "ãƒ’ãƒ³ãƒˆï¼šå‹é”ã‚’æ‹›å¾…ã—ã¦800ãƒã‚¤ãƒ³ãƒˆã‚’ã‚²ãƒƒãƒˆã—ã¾ã—ã‚‡ã†ã€‚",
        "è¨˜éŒ²ï¼š1åˆ†é–“ã«ãŠã§ã“ã§åµã‚’80å€‹å‰²ã£ãŸäººãŒã‚®ãƒã‚¹ã«è¼‰ã£ãŸãã†ã§ã™ï¼",
        "è±†çŸ¥è­˜ï¼šæ–°é®®ãªåµã¯æ°´ã«æ²ˆã¿ã€å¤ã„åµã¯æµ®ãã¾ã™ã€‚"
    ]
  },
  CN: { 
    label: "ä¸­æ–‡", title: "è›‹è›‹ç¢° â˜ï¸", subtitle: "å…¨ä¸–ç•Œä¸€èµ·å‡»ç¢ä¼ è¯´ä¹‹è›‹", users: "åœ¨çº¿", total: "æ€»è®¡", shop: "å•†åº—", myPoint: "ç§¯åˆ†", atk: "æ”»å‡»åŠ›", item1: "åŒé”¤", item2: "é’¢é•", item3: "ç‚¸è¯", item4: "é’»å¤´", item5: "æŒ–æ˜æœº", item6: "æ¿€å…‰æª", item7: "æ ¸å¼¹", modalTitle: "ğŸ‰ æ­å–œï¼ ğŸ‰", modalDesc: "æ‚¨å®Œæˆäº†æœ€åä¸€å‡»ï¼Œå‡»ç¢äº†é¸¡è›‹ï¼æ‚¨å°±æ˜¯ä¼ è¯´ä¸­çš„ç ´åè€…ã€‚", modalPrize: "è¯·è¾“å…¥æ‚¨çš„ç”µå­é‚®ç®±ä»¥é¢†å–å¥–å“ï¼š", send: "æäº¤é¢†å¥–", adText: "å¹¿å‘ŠåŒºåŸŸ", powerClick: "âš¡ è¶…çº§ç‚¹å‡» (+100) âš¡", watchAd: "çœ‹å¹¿å‘Šå¼ºåŠ›æ”»å‡»", logo: "è›‹è›‹ç¢° â˜ï¸",
    gameRuleTitle: "æ¸¸æˆç©æ³•", gameRule1: "- ç‚¹å‡»è›‹ä»¥å‡å°‘å…¶HPã€‚", gameRule2: "- æ”¶é›†ç§¯åˆ†è´­ä¹°é“å…·ã€‚", gameRule3: "- ä¸å…¨ä¸–ç•Œçš„ç©å®¶ä¸€èµ·å‡»ç¢è›‹ï¼", noticeTitle: "æ³¨æ„äº‹é¡¹", notice1: "- å¼‚å¸¸æ¸¸æˆè¡Œä¸ºå¯èƒ½ä¼šè¢«å°ç¦ã€‚", notice2: "- æœ¬æ¸¸æˆå¯èƒ½ä¼šè¢«é‡ç½®ã€‚", prizeTitle: "æœ¬æœŸå¥–å“", contactTitle: "å•†åŠ¡åˆä½œ", myInfoTitle: "æˆ‘çš„ä¿¡æ¯", totalClick: "æ€»ç‚¹å‡»æ•°",
    notEnoughPoints: "ç§¯åˆ†ä¸è¶³ï¼", alreadyShared: "æœ¬è½®å·²é¢†å–åˆ†äº«å¥–åŠ±ï¼", shareSuccess: "é“¾æ¥å·²åˆ†äº«ï¼å¥½å‹è¿›å…¥æ¸¸æˆæ—¶æ‚¨å°†è·å¾—800ç§¯åˆ†ã€‚", inviteSuccess: "å¥½å‹å·²åŠ å…¥ï¼è·å¾—800ç§¯åˆ†ï¼", sent: "å·²å‘é€ï¼", bought: "è´­ä¹°æˆåŠŸ:",
    newRoundReset: "æ–°ä¸€è½®å¼€å§‹äº†ï¼æ‰€æœ‰è¿›åº¦å·²é‡ç½®ã€‚",
    shopGuide: "ç‚¹å‡»å³ä¾§å•†åº—è´­ä¹°å¼ºåŠ›é“å…·ï¼",
    rivalryTitle: "å›½å®¶å¯¹æŠ—èµ›", gap: "å·®è·", waiting: "ç­‰å¾…ä¸­...", noRival: "æ— å¯¹æ‰‹",
    hallOfFame: "èœå•", recentPrizes: "è¿‘æœŸå¥–å“", noRecords: "æš‚æ— è·èƒœè€…ã€‚æˆä¸ºç¬¬ä¸€ä¸ªèµ¢å®¶å§ï¼",
    adWatchBtn: "ğŸ“º çœ‹å¹¿å‘Š (+2000P)", shareBtn: "ğŸ’¬ åˆ†äº« (+800P)",
    adReward: "+2000 ç§¯åˆ†", shareReward: "åˆ†äº«è·å¾—800P (æœ€å¤š5æ¬¡)",
    roundOverTitle: "å›åˆç»“æŸï¼", roundOverDesc: "æ­£åœ¨ç­‰å¾…ä¸‹ä¸€è½®...",
    checkingWinnerTitle: "æ­£åœ¨åˆ¤å®šèƒœè€…...", checkingWinnerDesc: "æ­£åœ¨ç¡®è®¤è°æ˜¯ä¼ è¯´ä¸­çš„ç ´åè€…ã€‚",
    winnerTimerWarning: "è¯·åœ¨5åˆ†é’Ÿå†…è¾“å…¥ã€‚", winnerExitMsg: "å·²å‘é€ï¼å³å°†é€€å‡º (æ‰“å¼€æ–°çª—å£)", loserMsg: "å¾ˆé—æ†¾ï¼Œè¿™æ¬¡å¤±è´¥äº†. å³å°†é€€å‡º (æ‰“å¼€æ–°çª—å£)", timeLeft: "å‰©ä½™æ—¶é—´",
    retryTitle: "å‡†å¤‡å¥½å†æ¬¡å°è¯•äº†å—ï¼Ÿ", retryBtn: "ğŸ”„ é‡æ–°è¿›å…¥æ¸¸æˆ",
    tapToClose: "(ç‚¹å‡»å…³é—­)",
    maxAtkTitle: "æœ€é«˜æ”»å‡»åŠ›", maxPointTitle: "æœ€é«˜ç§¯åˆ†", maxClickTitle: "æœ€é«˜ç‚¹å‡»æ•°", serverStatusTitle: "æœåŠ¡å™¨çŠ¶æ€", participants: "å‚ä¸è€…", queueLabel: "æ’é˜Ÿä¸­", spectators: "æ—è§‚è€…", totalOnline: "Total Online",
    soundOn: "éŸ³æ•ˆ", bgmOn: "BGM", vibrationOn: "éœ‡åŠ¨", touchGuide: "ç‚¹å‡»ä¸­é—´çš„è›‹ ğŸ‘ˆ ï¼",
    joinGame: "åŠ å…¥æ¸¸æˆ", joinQueue: "åŠ å…¥æ’é˜Ÿ", fullServer: "ä»…è§‚æˆ˜ (æ»¡å‘˜)",
    eggFacts: [
        "æç¤ºï¼šè´­ä¹°é“å…·å¯ä»¥å¤§å¹…æå‡æ”»å‡»åŠ›ï¼",
        "å†·çŸ¥è¯†ï¼šè›‹å£³ä¸Šæœ‰çº¦17,000ä¸ªæ°”å­”ã€‚",
        "æç¤ºï¼šé‚€è¯·å¥½å‹å¯è·å¾—800ç§¯åˆ†ã€‚",
        "è®°å½•ï¼šä¸€åˆ†é’Ÿå†…ç”¨é¢å¤´å‡»ç¢80ä¸ªé¸¡è›‹çš„äººåˆ›é€ äº†å‰å°¼æ–¯ä¸–ç•Œçºªå½•ï¼",
        "å†·çŸ¥è¯†ï¼šæ–°é²œçš„é¸¡è›‹ä¼šæ²‰å…¥æ°´åº•ï¼Œé™ˆè›‹åˆ™ä¼šæµ®èµ·æ¥ã€‚"
    ]
  }
};

const getFlagEmoji = (countryCode) => {
  if (!countryCode) return 'ğŸŒ';
  const codePoints = countryCode.toUpperCase().split('').map(char => 127397 + char.charCodeAt());
  return String.fromCodePoint(...codePoints);
};

const TOOL_NAMES = {
  hammer: 'item1',
  pickaxe: 'item2',
  dynamite: 'item3',
  drill: 'item4',
  excavator: 'item5',
  laser: 'item6',
  nuke: 'item7',
  fist: 'fist'
};

function App() {
  const [route, setRoute] = useState(window.location.hash);
  
  // Custom Hook for API State
  const { serverState, API_URL, error: serverError, role, queuePos, etaSec, addClick, connected, clientId, winningToken, winStartTime, prizeSecretImageUrl, connect, rewardEvent } = useGameState(); 
  
  // Custom Hook for Push Notifications
  usePushNotifications(API_URL, clientId);
  
  // Local HP for Optimistic Updates
  const [hp, setHp] = useState(1000000);

  // [Performance] Batch Updates Refs
  const accumulatedDamage = useRef(0);
  const accumulatedPoints = useRef(0);
  const accumulatedClicks = useRef(0);

  // [Performance] Flush Updates Loop (100ms throttle)
  useEffect(() => {
    const timer = setInterval(() => {
        if (accumulatedDamage.current > 0 || accumulatedPoints.current > 0) {
            const dmg = accumulatedDamage.current;
            const pts = accumulatedPoints.current;
            const clks = accumulatedClicks.current;
            
            accumulatedDamage.current = 0;
            accumulatedPoints.current = 0;
            accumulatedClicks.current = 0;

            setHp(prev => Math.max(0, prev - dmg));
            setMyPoints(prev => prev + pts);
            
            if (clks > 0) {
                setMyTotalClicks(prev => prev + clks);
            }
        }
    }, 100); 

    return () => clearInterval(timer);
  }, []);

  // [Performance] Persist Data Loop (1s throttle)
  useEffect(() => {
      const saveTimer = setInterval(() => {
          // Only write if changed? localStorage writes are cheap if value is same but still sync I/O.
          // React state is source of truth.
          localStorage.setItem('egg_breaker_clicks', myTotalClicks.toString());
          localStorage.setItem('saved_points', myPoints.toString());
      }, 1000);
      return () => clearInterval(saveTimer);
  }, [myTotalClicks, myPoints]);

  // const [isShaking, setIsShaking] = useState(false); // Removed for performance
  const [myPoints, setMyPoints] = useState(() => {
      return parseInt(localStorage.getItem('saved_points') || '0', 10);
  });
  const [clickPower, setClickPower] = useState(1);
  const [isWinner, setIsWinner] = useState(false);
  const [winnerEmail, setWinnerEmail] = useState("");
  const [emailSubmitted, setEmailSubmitted] = useState(false);
  const [myCountry, setMyCountry] = useState("KR"); // Default KR
  const [lang, setLang] = useState(TRANSLATIONS.KR); // Default KR
  const [currentTool, setCurrentTool] = useState("fist");
  const [showCountrySelect, setShowCountrySelect] = useState(false);
  const [adWatchCount, setAdWatchCount] = useState(0); 
  const [shareCount, setShareCount] = useState(0); // [New] Share Counter
  const [myTotalClicks, setMyTotalClicks] = useState(() => {
    return parseInt(localStorage.getItem('egg_breaker_clicks') || '0', 10);
  });
  
  // Track previous round to detect changes
  const prevRound = useRef(null);
  
  // Mobile Panel State: 'none', 'left', 'right'
  const [mobilePanel, setMobilePanel] = useState('none');
  const [notification, setNotification] = useState('');
  const [showGuide, setShowGuide] = useState(true);
  const [lastActivity, setLastActivity] = useState(Date.now());
  const [hideAnnouncement, setHideAnnouncement] = useState(false);

  // Timestamp for synchronization
  const lastServerTs = useRef(0);
  const buyAudioRef = useRef(null); // Singleton for buy sound

  // Timers
  const [winnerCountdown, setWinnerCountdown] = useState(300); // 5 minutes
  const [exitCountdown, setExitCountdown] = useState(null); // For winner after submit
  const [loserCountdown, setLoserCountdown] = useState(null); // For losers
  const [showLoserMessage, setShowLoserMessage] = useState(false); // Delay for "Checking..."

  // Retry & Spectator State
  const [showRetry, setShowRetry] = useState(false);
  const [isSpectating, setIsSpectating] = useState(false);
  const isFirstLoad = useRef(true); // Track first load to detect latecomers
  
  // Queue Status for Full Server
  const [queueStatus, setQueueStatus] = useState('WAITING'); 

  // [Modified] Handle Full Server -> Spectator Mode
  useEffect(() => {
      if (serverError === 'FULL') {
          showNotification("ëŒ€ê¸°ì—´ì´ ê½‰ ì°¨ì„œ ê´€ì „ ëª¨ë“œë¡œ ì…ì¥í•©ë‹ˆë‹¤.");
          // No auto-reload, just stay as spectator
      }
  }, [serverError]);

  // HP Threshold Announcements
  const lastStage = useRef(0);
  useEffect(() => {
      // 10ë‹¨ê³„ (10% ë‹¨ìœ„)
      const currentStage = Math.ceil(10 - ((hp / 1000000) * 100 / 10));
      
      if (currentStage > lastStage.current && hp > 0) {
          if (currentStage > 1) { // 1ë‹¨ê³„ëŠ” ì‹œì‘ì‹œ ì´ë¯¸ ì ìš©ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì œì™¸í•˜ê±°ë‚˜ í•„ìš”ì‹œ í¬í•¨
               showNotification(`${lang.crackWarning} (Stage ${currentStage})`);
          }
          lastStage.current = currentStage;
      } else if (hp >= 1000000) {
          lastStage.current = 0;
      }
  }, [hp, lang]);

  // Data from Server State
  const announcement = serverState.nextPrizeName 
    ? `ğŸ ì´ë²ˆ ë¼ìš´ë“œ ìƒí’ˆ: ${serverState.nextPrizeName}` 
    : (serverState.announcement || "");
  const prize = serverState.prize || "";
  const prizeUrl = serverState.prizeUrl || "";
  const adUrl = serverState.adUrl || "";

  // Helper for Game End (Open New Window + Show Retry Screen)
  const handleGameEnd = (url) => {
      // [UX] Removed auto-popup to prevent blocking. 
      // Just show the retry/spectating UI with a button.
      
      // Show Retry/Spectating UI inside the game instead of a separate screen
      setShowRetry(true);
      setIsSpectating(true); 
  };

  const handleRetry = () => {
      // Complete reset by reloading the page
      window.location.reload();
  };

  // Winner Timer (5 min limit)
  useEffect(() => {
    let timer;
    if (isWinner && !emailSubmitted && !showRetry) {
        if (winStartTime) {
            // [New] Sync with Server Time
            const updateTimer = () => {
                const elapsed = Math.floor((Date.now() - winStartTime) / 1000);
                const remaining = Math.max(0, 300 - elapsed);
                setWinnerCountdown(remaining);
                if (remaining <= 0) {
                    alert("ì‹œê°„ì´ ì´ˆê³¼ë˜ì–´ ìš°ìŠ¹ ìê²©ì´ ë°•íƒˆë˜ì—ˆìŠµë‹ˆë‹¤.");
                    window.location.reload();
                }
            };
            
            updateTimer(); // Initial call
            timer = setInterval(updateTimer, 1000);
        } else if (winnerCountdown > 0) {
            // Fallback
            timer = setInterval(() => {
                setWinnerCountdown(prev => prev - 1);
            }, 1000);
        }
    } else if (winnerCountdown === 0 && isWinner && !emailSubmitted && !showRetry) {
       // Time expired for winner (Legacy path)
       alert("ì‹œê°„ì´ ì´ˆê³¼ë˜ì–´ ìš°ìŠ¹ ìê²©ì´ ë°•íƒˆë˜ì—ˆìŠµë‹ˆë‹¤.");
       window.location.reload();
    }
    return () => clearInterval(timer);
  }, [isWinner, emailSubmitted, winnerCountdown, adUrl, showRetry, winStartTime]);

  // Winner Exit Timer (after submission)
  useEffect(() => {
    let timer;
    if (exitCountdown !== null && exitCountdown > 0 && !showRetry) {
        timer = setInterval(() => setExitCountdown(prev => prev - 1), 1000);
    } else if (exitCountdown === 0 && !showRetry) {
        handleGameEnd(adUrl);
    }
    return () => clearInterval(timer);
  }, [exitCountdown, adUrl, showRetry]);

  // Loser Logic & Timer
  useEffect(() => {
      let checkTimer;
      let countdownTimer;

      if (hp <= 0 && !isWinner && !showRetry && !isSpectating) {
          // 1. Wait 4 seconds before showing "Failed" (to allow server sync)
          if (!showLoserMessage) {
              checkTimer = setTimeout(() => {
                  setShowLoserMessage(true);
                  setLoserCountdown(10); // 10 seconds to exit
              }, 4000);
          }

          // 2. Start Countdown if message is shown
          if (showLoserMessage && loserCountdown !== null && loserCountdown > 0) {
              countdownTimer = setInterval(() => {
                  setLoserCountdown(prev => prev - 1);
              }, 1000);
          } else if (showLoserMessage && loserCountdown === 0) {
              handleGameEnd(adUrl);
          }
      } else {
          // Reset if HP restored (new round) or became winner
          if (hp > 0) {
            setShowLoserMessage(false);
            setLoserCountdown(null);
            setIsSpectating(false);
          }
      }

      return () => {
          clearTimeout(checkTimer);
          clearInterval(countdownTimer);
      };
  }, [hp, isWinner, showLoserMessage, loserCountdown, adUrl, showRetry, isSpectating]);

  // 1. Definition FIRST
  const changeCountry = (code) => {
    const targetLang = ["KR", "JP", "CN"].includes(code) ? code : "US";
    setMyCountry(code);
    setLang(TRANSLATIONS[targetLang]);
    setShowCountrySelect(false);
  };

  // 2. useEffects using functions
  useEffect(() => {
    const detectCountry = () => {
        try {
            // [Perf] Removed external API call (ipwho.is)
            // Use browser language as a heuristic or fallback to KR
            const lang = navigator.language || navigator.userLanguage || "ko-KR";
            if (lang.includes("ko")) changeCountry("KR");
            else if (lang.includes("ja")) changeCountry("JP");
            else if (lang.includes("zh")) changeCountry("CN");
            else changeCountry("US");
        } catch (e) {
            changeCountry("KR");
        }
    };
    detectCountry();
  }, []);

  // Handle Invite Link Check
  useEffect(() => {
      const checkInvite = async (url) => {
          console.log(`[App] URL: ${url}`);
          if (!url) return;
          const params = new URLSearchParams(new URL(url).search);
          const referrer = params.get('referrer');
          console.log(`[App] Ref: ${referrer}, Me: ${clientId}`);
          
          // Remove client-side check to allow round resets to work
          if (referrer && referrer !== clientId) {
              // [New] Local duplication check to prevent 400 errors on refresh
              const checkKey = `egg_invite_checked_${referrer}`;
              const lastChecked = localStorage.getItem(checkKey);
              // If checked within last 24 hours, skip
              if (lastChecked && (Date.now() - parseInt(lastChecked, 10) < 24 * 60 * 60 * 1000)) {
                  console.log("[App] Invite already checked locally (skipping).");
                  return;
              }

              try {
                  console.log("[App] Sending invite req...");
                  const res = await fetch(`${API_URL}/api/invite-reward`, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ from: referrer, to: clientId })
                  });
                  const json = await res.json();
                  console.log(`[App] Resp: ${res.status} ${JSON.stringify(json)}`);
                  
                  // If success or duplicate/invalid (400), mark as checked to avoid retry
                  if (res.ok || res.status === 400) {
                      localStorage.setItem(checkKey, Date.now().toString());
                  }

                  if (res.ok) {
                      console.log("Invite verified by server!");
                      // Optional: mark locally if needed for UI, but rely on server for logic
                  }
              } catch (e) {
                  console.error("Invite check failed", e);
                  console.log(`[App] Err: ${e.message}`);
              }
          } else {
              console.log("[App] No valid referrer");
          }
      };
      
      checkInvite(window.location.href);
      
      // For Capacitor (Deep Links)
      if (window.Capacitor) {
          import('@capacitor/app').then(({ App: CapApp }) => {
              CapApp.addListener('appUrlOpen', data => {
                  checkInvite(data.url);
              });
          });
      }
  }, [clientId, API_URL]);

  // Handle Reward Events (Invites)
  useEffect(() => {
    if (rewardEvent) {
        setMyPoints(prev => prev + rewardEvent.amount);
        // Persist earned points locally as well
        const currentStored = parseInt(localStorage.getItem('saved_points') || '0', 10);
        localStorage.setItem('saved_points', (currentStored + rewardEvent.amount).toString());

        let msg = rewardEvent.msg;
        if (msg === "INVITE_REWARD_MSG") {
            msg = lang.inviteSuccess || "Friend joined! +800P";
        } else if (msg === "INVITE_REWARD_WELCOME") {
            msg = `${lang.welcomeBack || "Welcome back!"} +${rewardEvent.amount}P`;
        }

        showNotification(msg);
        console.log(`[App] Reward: ${msg}`);
    }
  }, [rewardEvent, lang]);

  // Sync Local HP with Server HP (Correction with Pending Damage)
  useEffect(() => {
      if (serverState.hp !== undefined) {
          const ts = serverState.lastUpdatedAt || 0;
          
          if (ts >= lastServerTs.current) {
              lastServerTs.current = ts;
              
              // [Sticky HP Logic] 
              setHp(prevHp => {
                  if (serverState.hp < prevHp || isFirstLoad.current) {
                      return serverState.hp;
                  }
                  if (prevRound.current && serverState.round !== prevRound.current) {
                      return serverState.hp;
                  }
                  return prevHp;
              });

              // Latecomer Detection
              if (isFirstLoad.current) {
                  if (serverState.hp <= 0) {
                      setIsSpectating(true);
                  }
                  
                  // [Fix] Points are already loaded in useState initial value. 
                  // Adding them again here causes double counting. Removed.

                  isFirstLoad.current = false;
              }
          } 
      }
  }, [serverState.hp, serverState.lastUpdatedAt, myCountry, isWinner]);
  
  useEffect(() => {
    // Round change handling
    if (prevRound.current && serverState.round && serverState.round !== prevRound.current) {
        setMyPoints(0);
        setClickPower(1);
        setCurrentTool('fist');
        setAdWatchCount(0);
        setShareCount(0); // Reset share count
        setMyTotalClicks(0);
        localStorage.setItem('egg_breaker_clicks', '0');
        localStorage.setItem('saved_points', '0'); // Reset saved points too
    }
    if (serverState.round) {
        prevRound.current = serverState.round;
    }
  }, [serverState.round, serverState.status, lang]);

  useEffect(() => {
    const handleHashChange = () => {
      setRoute(window.location.hash);
    };

    window.addEventListener('hashchange', handleHashChange);
    return () => window.removeEventListener('hashchange', handleHashChange);
  }, []);

  useEffect(() => {
    if (window.Kakao && !window.Kakao.isInitialized()) {
        const kakaoKey = import.meta.env.VITE_KAKAO_JAVASCRIPT_KEY;
        if(kakaoKey && kakaoKey !== 'YOUR_KAKAO_JAVASCRIPT_KEY') {
             try { window.Kakao.init(kakaoKey); } catch(e) { console.error("Kakao Init Failed:", e); }
        }
    }
  }, []);

  // Inactivity Timer for Guide
  useEffect(() => {
    const timer = setInterval(() => {
      if (Date.now() - lastActivity > 10000 && !showGuide) {
        setShowGuide(true);
      }
    }, 1000);
    return () => clearInterval(timer);
  }, [lastActivity, showGuide]);

  const handleClick = async () => {
    if (hp <= 0 || serverState.status === 'FINISHED' || role === 'spectator') return;
    
    // Reset activity timer
    setLastActivity(Date.now());
    setShowGuide(false);
    
    // 1. [Performance] Accumulate Changes (UI update is batched in useEffect)
    accumulatedDamage.current += clickPower;
    accumulatedPoints.current += clickPower;
    accumulatedClicks.current += 1;
    
    // 2. Use Hook to Add Click (Hook handles server batching)
    addClick(clickPower, myCountry, myPoints + accumulatedPoints.current, myTotalClicks + accumulatedClicks.current);
    
    // If HP hits 0 locally (Optimistic check)
    if (hp - accumulatedDamage.current <= 0) {
       setShowLoserMessage(true); // Temporarily show checking status
    }
  };

  // Check for Winning Token from Server
  useEffect(() => {
      if (winningToken) {
          setIsWinner(true);
          setShowLoserMessage(false); // Clear checking status
      }
  }, [winningToken]);

  const buyItem = async (cost, powerAdd, toolName) => {
    if (myPoints >= cost) {
      setMyPoints(prev => prev - cost);
      setClickPower(prev => prev + powerAdd);
      setCurrentTool(toolName);
      
      // Play Buy Sound (Hybrid)
      try {
          if (Capacitor.isNativePlatform()) {
              await NativeAudio.play({ assetId: 'buy' }).catch(() => {});
          } else {
              if (!buyAudioRef.current) {
                  buyAudioRef.current = new Audio('/sounds/buy.mp3');
                  buyAudioRef.current.volume = 1.0;
              }
              buyAudioRef.current.currentTime = 0;
              await buyAudioRef.current.play().catch(e => {
                  if (e.name !== 'NotSupportedError' && e.name !== 'NotAllowedError') {
                      console.warn("Buy sound play failed:", e);
                  }
              });
          }
      } catch(e) { /* Ignore setup errors */ }

      const localizedToolName = lang[TOOL_NAMES[toolName]] || toolName;
      showNotification(`${lang.bought} ${localizedToolName}!`);
    } else {
      showNotification(lang.notEnoughPoints);
    }
  };

  const submitWinnerEmail = async (customEmail = null) => {
    const targetEmail = customEmail || winnerEmail;
    
    if (!customEmail) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(targetEmail)) {
            showNotification("ì´ë©”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
            return;
        }
    }
    
    try {
        await fetch(`${API_URL}/api/winner`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: targetEmail, country: myCountry, token: winningToken })
        });
        setEmailSubmitted(true);
        showNotification("ì´ë©”ì¼ì´ ì •ìƒì ìœ¼ë¡œ ì ‘ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤!");
        setExitCountdown(5); 
    } catch(e) {
        console.error("Winner submit failed", e);
        showNotification("Failed to send. Please try again.");
    }
  };

  const showNotification = (msg) => {
      setNotification(msg);
      setTimeout(() => setNotification(''), 2000);
  };

  const handleComboReward = (points, msg) => {
      setMyPoints(prev => prev + points);
      showNotification(msg);
      const currentStored = parseInt(localStorage.getItem('saved_points') || '0', 10);
      localStorage.setItem('saved_points', (currentStored + points).toString());
  };

  const toggleMobilePanel = (panel) => {
    if (mobilePanel === panel) {
        setMobilePanel('none');
    } else {
        setMobilePanel(panel);
        setShowCountrySelect(false); 
    }
  };

  const handleLangToggle = () => {
      if (!showCountrySelect) {
          setMobilePanel('none'); 
          setShowCountrySelect(true);
      } else {
          setShowCountrySelect(false);
      }
  };

  const handleKakaoShare = async () => {
    if (!window.Kakao || !window.Kakao.isInitialized()) {
        showNotification("Kakao SDK not initialized.");
        return;
    }

    if (shareCount >= 5) {
        showNotification(lang.alreadyShared || "ì´ë²ˆ ë¼ìš´ë“œ ê³µìœ  í•œë„(5íšŒ)ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤.");
        return;
    }
    
    const currentUrl = new URL(window.location.href);
    if (clientId) {
        currentUrl.searchParams.set('referrer', clientId);
    }
    const shareUrl = currentUrl.toString();

    try {
        window.Kakao.Share.sendDefault({
          objectType: 'feed',
          content: {
            title: lang.title,
            description: lang.subtitle,
            imageUrl: 'https://worldegg-breaking.pages.dev/vite.svg',
            link: { mobileWebUrl: shareUrl, webUrl: shareUrl },
          },
          buttons: [{ title: 'Play Now', link: { mobileWebUrl: shareUrl, webUrl: shareUrl } }],
          installTalk: true, 
        });

        await new Promise(resolve => setTimeout(resolve, 1500));

        const reward = 800;
        setMyPoints(prev => prev + reward);
        setShareCount(prev => prev + 1);
        const currentStored = parseInt(localStorage.getItem('saved_points') || '0', 10);
        localStorage.setItem('saved_points', (currentStored + reward).toString());
        showNotification(`${lang.shareSuccess} (${shareCount + 1}/5)`);
    } catch (e) {
        console.error("Kakao Share Error:", e);
        if (e.name === 'NotAllowedError' || e.message?.includes('intent')) {
            showNotification("ì¹´ì¹´ì˜¤í†¡ ì•± ì‹¤í–‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (ëª¨ë°”ì¼ ê¸°ê¸°ì—ì„œ ì‹œë„í•´ì£¼ì„¸ìš”)");
        } else {
            showNotification("ê³µìœ í•˜ê¸° ë„ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. (ë¸Œë¼ìš°ì € ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”)");
        }
    }
  };

  const handleAdWatch = () => {
    if (adWatchCount >= 1) {
        showNotification("ì´ë²ˆ ë¼ìš´ë“œ ê´‘ê³  ì‹œì²­(1íšŒ)ì„ ì´ë¯¸ ì™„ë£Œí•˜ì…¨ìŠµë‹ˆë‹¤!");
        return;
    }
    if (adUrl) {
        window.open(adUrl, '_blank');
    } else {
        showNotification("í˜„ì¬ ì—°ê²°ëœ ê´‘ê³ ê°€ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }
    const reward = 2000;
    setMyPoints(prev => prev + reward);
    setAdWatchCount(prev => prev + 1);
    const currentStored = parseInt(localStorage.getItem('saved_points') || '0', 10);
    localStorage.setItem('saved_points', (currentStored + reward).toString());
    showNotification(`ê´‘ê³  ì‹œì²­ ì™„ë£Œ! ${reward} í¬ì¸íŠ¸ê°€ ì§€ê¸‰ë˜ì—ˆìŠµë‹ˆë‹¤.`);
  };

  if (route === '#admin') return <Admin />;

  if (serverState.status === 'LOADING') {
      return (
          <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '100vh', background: '#fff' }}>
              <h2>ğŸ”„ Connecting...</h2>
              <p>ì„œë²„ì™€ ì—°ê²° ì¤‘ì…ë‹ˆë‹¤.</p>
          </div>
      );
  }

  if (serverState.status === 'ERROR') {
      return (
          <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '100vh', background: '#fff', padding: '20px', textAlign: 'center' }}>
              <h2 style={{color: 'red'}}>âš ï¸ Connection Error</h2>
              <p>{serverState.announcement}</p>
              <button onClick={() => window.location.reload()} style={{marginTop: '20px'}}>Retry</button>
          </div>
      );
  }

  const countryStats = Object.entries(serverState.clicksByCountry || {}).sort((a, b) => b[1] - a[1]);
  const onlineUsersCount = (serverState.onlinePlayers || 0) + (serverState.onlineSpectatorsApprox || 0);

  return (
    <div className="app-container">
      {notification && (
        <div className="notification-toast">
            <span>ğŸ›ï¸</span> {notification}
        </div>
      )}
      <Header lang={lang} myCountry={myCountry} getFlagEmoji={getFlagEmoji} onToggleLanguage={handleLangToggle} showCountrySelect={showCountrySelect} changeCountry={changeCountry} toggleMobilePanel={toggleMobilePanel} />
      {announcement && !hideAnnouncement && (
        <div onClick={() => setHideAnnouncement(true)} className="announcement-bar">
          ğŸ“¢ {announcement} <span style={{ fontSize: '0.8rem', opacity: 0.7 }}>{lang.tapToClose}</span>
        </div>
      )}
      {(mobilePanel !== 'none' || showCountrySelect) && (
        <div onClick={() => { setMobilePanel('none'); setShowCountrySelect(false); }} className="backdrop" />
      )}
      {mobilePanel === 'none' && (
        <>
          <div className="side-toggle left" onClick={() => toggleMobilePanel('left')}><span>ğŸ‘‰</span><span className="side-label">{lang.users}</span></div>
          <div className="side-toggle right" onClick={() => toggleMobilePanel('right')}><span>ğŸ‘ˆ</span><span className="side-label">{lang.shop}</span></div>
        </>
      )}
      <div className="main-layout">
        <LeftPanel lang={lang} serverState={serverState} countryStats={countryStats} onlineUsersCount={onlineUsersCount} prize={prize} prizeUrl={prizeUrl} getFlagEmoji={getFlagEmoji} isOpen={mobilePanel === 'left'} toggleMobilePanel={toggleMobilePanel} />
        <InfoPanel lang={lang} recentWinners={serverState.recentWinners || []} prize={prize} prizeUrl={prizeUrl} isOpen={mobilePanel === 'info'} toggleMobilePanel={toggleMobilePanel} />
        <div style={{ position: 'relative', flex: 1, display: 'flex', justifyContent: 'center' }}>
            <GameArea lang={lang} hp={hp} clickPower={clickPower} myPoints={myPoints} isWinner={isWinner} emailSubmitted={emailSubmitted} winnerEmail={winnerEmail} setWinnerEmail={setWinnerEmail} submitWinnerEmail={submitWinnerEmail} handleClick={handleClick} currentTool={currentTool} buyItem={buyItem} notification={notification} handleAdWatch={handleAdWatch} adWatchCount={adWatchCount} showGuide={showGuide} winnerCountdown={winnerCountdown} exitCountdown={exitCountdown} loserCountdown={loserCountdown} showLoserMessage={showLoserMessage} isSpectating={isSpectating} showRetry={showRetry} handleRetry={handleRetry} clientId={clientId} serverState={serverState} API_URL={API_URL} myCountry={myCountry} winningToken={winningToken} prizeSecretImageUrl={prizeSecretImageUrl} connected={connected} onComboReward={handleComboReward} />
            {!connected && serverState.status === 'PLAYING' && (
                <div className="join-overlay">
                    <button onClick={connect} className="pulse-btn" disabled={serverState.onlinePlayers >= 1000 && (serverState.queueLength || 0) >= 1000}>
                        {serverState.onlinePlayers < 1000 ? `âš”ï¸ ${lang.joinGame || "JOIN GAME"}` : (serverState.queueLength || 0) < 1000 ? `â³ ${lang.joinQueue || "Join Queue"}` : `ğŸš« ${lang.fullServer || "Full"}`}
                    </button>
                </div>
            )}
        </div>
        <RightPanel lang={lang} buyItem={buyItem} myPoints={myPoints} clickPower={clickPower} myTotalClicks={myTotalClicks} handleKakaoShare={handleKakaoShare} isOpen={mobilePanel === 'right'} toggleMobilePanel={toggleMobilePanel} shareCount={shareCount} />
      </div>
    </div>
  );
}
export default App;

--- File: egg-breaker/src/components/GameArea.jsx ---
import React, { useState, useRef, useEffect } from 'react';
import { Haptics, ImpactStyle } from '@capacitor/haptics';
import { NativeAudio } from '@capacitor-community/native-audio';
import { Capacitor } from '@capacitor/core';

const CrackedEgg = React.memo(React.forwardRef(({ hp, maxHp, tool, onEggClick }, ref) => {
    const percentage = (hp / maxHp) * 100;
    const stage = Math.ceil(10 - (percentage / 10)); 
    const isCritical = percentage < 20 && hp > 0;
    const isBroken = hp <= 0;
    const randomSeed = Math.floor((hp % 7)); 

    let eyeLeft = <circle cx="75" cy="110" r="8" fill="#5d4037" />;
    let eyeRight = <circle cx="125" cy="110" r="8" fill="#5d4037" />;
    let mouth = <path d="M90 135 Q100 145 110 135" fill="none" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />;
    let blush = <><ellipse cx="65" cy="125" rx="8" ry="4" fill="#ffb6c1" opacity="0.6" /><ellipse cx="135" cy="125" rx="8" ry="4" fill="#ffb6c1" opacity="0.6" /></>;
    let extra, eyeLeftRed, eyeRightRed;

    if (percentage < 70) { 
        eyeLeft = <path d="M68 115 Q75 105 82 115" fill="none" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />;
        eyeRight = <path d="M118 115 Q125 105 132 115" fill="none" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />;
        mouth = <path d="M90 145 Q100 135 110 145" fill="none" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />;
        extra = <path d="M65 125 Q60 135 65 145 M135 125 Q140 135 135 145" fill="none" stroke="#a1c4fd" strokeWidth="2" />;
    }
    if (isCritical) { 
        eyeLeft = <g><path d="M65 105 L85 115 L65 120" fill="red" /><circle cx="72" cy="112" r="2" fill="#fff" /></g>;
        eyeRight = <g><path d="M135 105 L115 115 L135 120" fill="red" /><circle cx="128" cy="112" r="2" fill="#fff" /></g>;
        mouth = <path d="M85 140 L90 130 L95 140 L100 130 L105 140 L110 130 L115 140" fill="none" stroke="#5d4037" strokeWidth="2" />;
        blush = null;
    }
    if (isBroken) {
        eyeLeft = <path d="M68 103 L82 117 M82 103 L68 117" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />;
        eyeRight = <path d="M118 103 L132 117 M132 103 L118 117" stroke="#5d4037" strokeWidth="3" strokeLinecap="round" />;
        mouth = <circle cx="100" cy="140" r="10" fill="none" stroke="#5d4037" strokeWidth="3" />;
        blush = null;
    }

    return (
        <div ref={ref} className={`egg-svg-container cursor-${tool}`} style={{ transition: 'transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275)' }}>
            <svg viewBox="0 0 200 250" className="egg-svg" style={{ overflow: 'visible' }}>
                <defs><radialGradient id="eggGradient" cx="40%" cy="30%" r="80%"><stop offset="0%" stopColor={isCritical ? "#800000" : "#ffdde1"} /><stop offset="100%" stopColor={isCritical ? "#200000" : "#ff9a9e"} /></radialGradient></defs>
                <ellipse cx="100" cy="125" rx="80" ry="110" fill="url(#eggGradient)" onPointerDown={onEggClick} style={{ cursor: 'pointer', touchAction: 'none' }} />
                <g className="egg-face" style={{ pointerEvents: 'none' }}>{blush}{eyeLeft}{eyeRight}{mouth}{extra}</g>
                <g stroke="#5d4037" strokeWidth="3" strokeLinecap="round" fill="none" opacity="0.7" style={{ pointerEvents: 'none' }}>
                    {stage >= 1 && <path d="M100 30 L110 50 L90 60" />}{stage >= 2 && <path d="M50 100 L70 110 L60 130" />}{stage >= 3 && <path d="M140 80 L130 100 L150 110" />}{stage >= 4 && <path d="M80 180 L100 190 L90 210" />}{stage >= 5 && <path d="M30 140 L50 150 L40 170" />}{stage >= 6 && <path d="M160 150 L140 160 L150 180" />}{stage >= 7 && <path d="M70 50 L80 70 L60 80" strokeWidth="4" />}{stage >= 8 && <path d="M130 180 L120 200 L140 210" strokeWidth="4" />}{stage >= 9 && <path d="M100 220 V240 M40 60 L20 80" strokeWidth="5" />}{stage >= 10 && <path d="M170 100 L190 120 M10 120 L30 130" strokeWidth="5" />}
                </g>
                {isBroken && <path d="M20 125 Q100 160 180 125" fill="none" stroke="#5d4037" strokeWidth="10" style={{ pointerEvents: 'none' }} />}
            </svg>
        </div>
    );
}));

const TOOL_EMOJIS = { hammer: 'ğŸ”¨', pickaxe: 'â›ï¸', dynamite: 'ğŸ§¨', drill: 'ğŸ”©', excavator: 'ğŸšœ', laser: 'ğŸ”«', nuke: 'â˜¢ï¸', fist: 'ğŸ‘Š' };
const CUTE_PARTICLES = ['âœ¨', 'ğŸ’–', 'ğŸŒ¸', 'ğŸ­', 'â­', 'ğŸŒˆ', 'ğŸ¦', 'ğŸ€', 'ğŸµ', 'ğŸ‡'];

const GameArea = ({ lang, hp, clickPower, myPoints, isWinner, emailSubmitted, winnerEmail, setWinnerEmail, submitWinnerEmail, handleClick, currentTool, buyItem, notification, handleAdWatch, adWatchCount, showGuide, winnerCountdown, exitCountdown, loserCountdown, showLoserMessage, isSpectating, showRetry, handleRetry, clientId, serverState, API_URL, myCountry, winningToken, prizeSecretImageUrl, connected, onComboReward }) => {
    const canvasRef = useRef(null);
    const effectsRef = useRef([]); 
    const stageRectRef = useRef({ left: 0, top: 0, width: 0, height: 0 }); 
    const [isPrizeSaved, setIsPrizeSaved] = useState(false); 
    const stageRef = useRef(null); 
    const eggRef = useRef(null);   
    const wasActivePlayer = useRef(false);
    const [localLoserTimer, setLocalLoserTimer] = useState(null);
    const [showWinnerClaiming, setShowWinnerClaiming] = useState(false);
    const [isSettingsFocused, setIsSettingsFocused] = useState(false); 
    const lastSoundTime = useRef(0);
    const lastVibTime = useRef(0); 
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [combo, setCombo] = useState(0);
    const comboTimerRef = useRef(null);
    const [audioLoaded, setAudioLoaded] = useState(false); 
    const [isSoundOn, setIsSoundOn] = useState(() => JSON.parse(localStorage.getItem('soundOn') || 'true'));
    const [isBgmOn, setIsBgmOn] = useState(() => JSON.parse(localStorage.getItem('bgmOn') || 'true'));
    const [currentFactIndex, setCurrentFactIndex] = useState(0);
    const webAudioRefs = useRef({}); 
    const audioContextRef = useRef(null); 
    const bgmRef = useRef(null); 
    const currentPhaseRef = useRef('none');

    useEffect(() => {
        const timer = setInterval(() => setCurrentFactIndex(prev => (prev + 1) % (lang.eggFacts?.length || 1)), 6000);
        return () => clearInterval(timer);
    }, [lang.eggFacts]);

    useEffect(() => {
        let animationFrameId;
        let lastTime = 0;
        const renderLoop = (timestamp) => {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            const canvas = canvasRef.current;
            const ctx = canvas?.getContext('2d');
            if (canvas && ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                effectsRef.current = effectsRef.current.filter(effect => {
                    effect.life -= deltaTime;
                    if (effect.life <= 0) return false;
                    effect.y -= effect.vy * (deltaTime / 16);
                    effect.alpha = Math.min(1, effect.life / 300);
                    ctx.save();
                    ctx.globalAlpha = effect.alpha;
                    if (effect.type === 'text') {
                        ctx.translate(effect.x, effect.y);
                        ctx.rotate((effect.rotation || 0) * Math.PI / 180);
                        ctx.font = `900 ${effect.size}px 'Fredoka', sans-serif`;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.lineWidth = 4; ctx.strokeStyle = effect.val >= 10000 ? '#000' : '#fff';
                        ctx.strokeText(effect.text, 0, 0);
                        ctx.fillStyle = effect.color; ctx.fillText(effect.text, 0, 0);
                    } else if (effect.type === 'emoji') {
                        ctx.translate(effect.x, effect.y);
                        ctx.font = `${effect.size}px serif`;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(effect.text, 0, 0);
                    }
                    ctx.restore();
                    return true;
                });
            }
            animationFrameId = requestAnimationFrame(renderLoop);
        };
        animationFrameId = requestAnimationFrame(renderLoop);
        return () => cancelAnimationFrame(animationFrameId);
    }, []);

    useEffect(() => {
        const handleResize = () => {
            if (canvasRef.current && stageRef.current) {
                const rect = stageRef.current.getBoundingClientRect();
                stageRectRef.current = rect;
                const dpr = window.devicePixelRatio || 1;
                canvasRef.current.width = rect.width * dpr; canvasRef.current.height = rect.height * dpr;
                canvasRef.current.getContext('2d').scale(dpr, dpr);
                Object.assign(canvasRef.current.style, { width: `${rect.width}px`, height: `${rect.height}px`, position: 'absolute', top: 0, left: 0, pointerEvents: 'none', zIndex: 20 });
            }
        };
        window.addEventListener('resize', handleResize);
        window.addEventListener('scroll', handleResize);
        setTimeout(handleResize, 100);
        return () => { window.removeEventListener('resize', handleResize); window.removeEventListener('scroll', handleResize); };
    }, []);

    const handlePointerDown = (e) => {
        if (!connected) return;
        setIsSettingsFocused(false);
        const now = Date.now();
        if (now - lastVibTime.current > 80) { triggerVibration(); lastVibTime.current = now; }
        const nextCombo = combo + 1;
        setCombo(prev => {
            if (comboTimerRef.current) clearTimeout(comboTimerRef.current);
            comboTimerRef.current = setTimeout(() => setCombo(0), 1200);
            return prev + 1;
        });
        if ([10, 100, 1000].includes(nextCombo)) playToolSound('many_hit'); else playToolSound(currentTool);
        checkWebAudioAutoplay(); handleClick();
        if (eggRef.current) {
            eggRef.current.animate([{ transform: 'translate(0, 0) rotate(0deg)' }, { transform: 'translate(-3px, 2px) rotate(-2deg)', offset: 0.2 }, { transform: 'translate(3px, -2px) rotate(2deg)', offset: 0.4 }, { transform: 'translate(-3px, -2px) rotate(-2deg)', offset: 0.6 }, { transform: 'translate(3px, 2px) rotate(2deg)', offset: 0.8 }, { transform: 'translate(0, 0) rotate(0deg)' }], { duration: 150, easing: 'linear' });
        }
        const rect = stageRectRef.current;
        const x = rect.width > 0 ? e.clientX - rect.left : 100;
        const y = rect.width > 0 ? e.clientY - rect.top : 100;
        let scale = 1, toolSize = 30, dmgColor = '#ff6f61';
        if (clickPower >= 10000) dmgColor = '#ffd700'; else if (clickPower >= 1000) dmgColor = '#9c27b0'; else if (clickPower >= 100) dmgColor = '#e91e63'; else if (clickPower >= 10) dmgColor = '#ff9800';
        switch(currentTool) {
            case 'hammer': scale = 1.2; toolSize = 40; break;
            case 'pickaxe': scale = 1.5; toolSize = 50; break;
            case 'dynamite': scale = 2.0; toolSize = 70; break;
            case 'drill': scale = 2.5; toolSize = 90; break;
            case 'excavator': scale = 3.0; toolSize = 120; break;
            case 'laser': scale = 4.5; toolSize = 160; break;
            case 'nuke': scale = 7.0; toolSize = 200; break;
        }
        effectsRef.current.push({ type: 'text', text: `-${clickPower.toLocaleString()}`, x: x + Math.random()*20-10, y: y-40, val: clickPower, color: dmgColor, size: 24*scale, life: 800, vy: 2, rotation: Math.random()*30-15 });
        effectsRef.current.push({ type: 'emoji', text: TOOL_EMOJIS[currentTool] || 'ğŸ‘Š', x, y, size: toolSize, life: 500, vy: 0 });
        if (Math.random() > 0.5) effectsRef.current.push({ type: 'emoji', text: CUTE_PARTICLES[Math.floor(Math.random()*CUTE_PARTICLES.length)], x: x+Math.random()*60-30, y: y+Math.random()*60-30, size: 20*(0.8+Math.random()), life: 600, vy: 3 });
        if ([10, 100, 1000].includes(nextCombo)) {
            let txt = `${nextCombo} COMBO!`, clr = '#ff4081';
            if (nextCombo === 100) { txt = "100 COMBO!!"; clr = '#00e676'; } else if (nextCombo === 1000) { txt = "1000 COMBO!!!"; clr = '#ffea00'; }
            if (onComboReward && nextCombo >= 100) onComboReward(nextCombo === 100 ? 50 : 700, `${txt} +${nextCombo === 100 ? 50 : 700}P`);
            effectsRef.current.push({ type: 'text', text: txt, x, y: y-100, val: 0, color: clr, size: 40, life: 1000, vy: 1 });
        }
    };

    return (
        <main className="game-area">
            {isInQueue && <div className="modal-overlay"><div className="modal-content glass">â³ <h1>ëŒ€ê¸°ì—´ ëŒ€ê¸° ì¤‘...</h1><div className="spinner"></div></div></div>}
            <div style={{ position: 'absolute', top: 10, right: 10, display: 'flex', flexDirection: 'column', gap: 8, zIndex: 100, padding: 12, borderRadius: 18, background: isSettingsFocused ? 'rgba(255,255,255,0.85)' : 'rgba(255,255,255,0.15)', opacity: isSettingsFocused ? 1 : 0.25, cursor: 'pointer' }} onClick={(e) => { e.stopPropagation(); setIsSettingsFocused(true); }}>
                {[{ label: lang.soundOn || 'SFX', active: isSoundOn, toggle: () => { setIsSoundOn(p => { const n = !p; localStorage.setItem('soundOn', n); return n; }); } }, { label: lang.bgmOn || 'BGM', active: isBgmOn, toggle: () => { setIsBgmOn(p => { const n = !p; localStorage.setItem('bgmOn', n); return n; }); } }, { label: lang.vibrationOn || 'Vib', active: JSON.parse(localStorage.getItem('vibrationOn') || 'true'), toggle: () => { const n = !JSON.parse(localStorage.getItem('vibrationOn') || 'true'); localStorage.setItem('vibrationOn', n); if (n) Haptics.impact({ style: ImpactStyle.Light }); } }].map((item, idx) => (
                    <div key={idx} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8 }}>
                        <span style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>{item.label}</span>
                        <div onClick={(e) => { e.stopPropagation(); item.toggle(); }} style={{ width: 36, height: 20, background: item.active ? '#ff9a9e' : '#bbb', borderRadius: 20, position: 'relative' }}>
                            <div style={{ width: 16, height: 16, background: '#fff', borderRadius: '50%', position: 'absolute', top: 2, left: item.active ? 18 : 2, transition: 'left 0.3s' }} />
                        </div>
                    </div>
                ))}
            </div>
            <div className="header-glow"><p className="subtitle">{lang.subtitle}</p>{combo > 5 && <div className="combo-text">ğŸ”¥ {combo} COMBO! ğŸ”¥</div>}</div>
            <div className="egg-stage" ref={stageRef} style={{ position: 'relative' }}>
                <canvas ref={canvasRef} />
                <CrackedEgg ref={eggRef} hp={hp} maxHp={1000000} tool={currentTool} onEggClick={handlePointerDown} />
                {showGuide && <div className="guide-overlay">{lang.touchGuide}</div>}
            </div>
            {(isWinnerCheck || isFinished || showRetry) && (
                <div className="modal-overlay" onClick={e => e.stopPropagation()}>
                    <div className="modal-content glass">
                        {isFinished && (<>ğŸ <h2>{lang.roundOverTitle}</h2><p>{lang.roundOverDesc}</p><button onClick={handleRetry}>{lang.retryBtn || "ìƒˆë¡œê³ ì¹¨"}</button></>)}
                        {isWinnerCheck && isMyWin && (<><h2>{lang.modalTitle}</h2><p>{lang.modalDesc}</p><div className="timer-box">âš ï¸ {lang.timeLeft}: {formatTime(winnerCountdown)}</div>{prizeSecretImageUrl ? (<div className="prize-box">ğŸ <img src={prizeSecretImageUrl} />{isPrizeSaved ? <p>âœ… ì €ì¥ë¨</p> : <><a href={prizeSecretImageUrl} download onClick={() => setIsPrizeSaved(true)}>ğŸ“¥ ì´ë¯¸ì§€ ì €ì¥</a><button onClick={() => submitWinnerEmail("IMAGE_CLAIMED")}>ìˆ˜ë ¹ ì™„ë£Œ</button></>}</div>) : (<><input type="email" value={winnerEmail} onChange={e => setWinnerEmail(e.target.value)} /><button onClick={() => submitWinnerEmail()}>{lang.send}</button></>)}</>)}
                        {isWinnerCheck && !isMyWin && (<>{localLoserTimer !== null ? (<>ğŸ˜¢ <h2>ì‹¤íŒ¨</h2><p>{localLoserTimer}ì´ˆ í›„ ëŒ€ê¸°ì—´ ì´ë™</p></>) : (<><div className="spinner"></div><h2>ìŠ¹ì í™•ì¸ ì¤‘...</h2></>)}</>)}
                        {showRetry && !isFinished && !isWinnerCheck && (<>ğŸ‘€ <h2>ê´€ì „ ëª¨ë“œ</h2><button onClick={handleRetry}>{lang.retryBtn || "ë‹¤ì‹œ ì ‘ì†"}</button></>)}
                    </div>
                </div>
            )}
            <div className="hp-wrapper"><div className="hp-container"><div className="hp-bar" style={{ width: `${(hp/1000000)*100}%` }}></div></div><div className="hp-text">{hp.toLocaleString()} HP</div></div>
            {adWatchCount < 1 && <button className="power-btn" onClick={handleAdWatch}>{lang.adWatchBtn}</button>}
            <div className="status-row glass"><div>{lang.myPoint}: <span>{myPoints}</span></div><div>{lang.atk}: <span>x{clickPower}</span></div></div>
            <div className="egg-fact-box"><p>ğŸ¥š {lang.eggFacts ? lang.eggFacts[currentFactIndex] : "Loading..."}</p></div>
        </main>
    );
};
export default GameArea;

--- File: egg-breaker/src/hooks/useGameState.js ---
import { useState, useEffect, useRef, useCallback } from 'react';

let rawApiUrl = import.meta.env.VITE_API_URL || "http://localhost:8787";
if (rawApiUrl.endsWith('/api')) rawApiUrl = rawApiUrl.substring(0, rawApiUrl.length - 4);
if (rawApiUrl.endsWith('/')) rawApiUrl = rawApiUrl.substring(0, rawApiUrl.length - 1);
const API_URL = rawApiUrl;
const WS_URL = API_URL.replace(/^http/, 'ws') + "/ws";

export function useGameState() {
  const [serverState, setServerState] = useState({ hp: 1000000, maxHp: 1000000, round: 1, status: 'LOADING', clicksByCountry: {}, onlinePlayers: 0, onlineSpectatorsApprox: 0, maxAtk: 0, maxAtkCountry: "UN", maxPoints: 0, maxClicks: 0, announcement: "", prize: "", prizeUrl: "", adUrl: "", rev: 0, lastUpdatedAt: 0, recentWinners: [] });
  const [role, setRole] = useState(null);
  const [queuePos, setQueuePos] = useState(null);
  const [etaSec, setEtaSec] = useState(null);
  const [error, setError] = useState(null);
  const [connected, setConnected] = useState(false);
  const [winningToken, setWinningToken] = useState(null);
  const [winStartTime, setWinStartTime] = useState(null);
  const [prizeSecretImageUrl, setPrizeSecretImageUrl] = useState(null);
  const [rewardEvent, setRewardEvent] = useState(null);
  const wsRef = useRef(null);
  const clickAccumulator = useRef(0);
  const maxPowerInBatch = useRef(0);
  const latestPoints = useRef(0);
  const latestTotalClicks = useRef(0);
  const countryRef = useRef("UN");
  const pollingIntervalRef = useRef(null);
  const clientId = useRef(() => {
      let stored = localStorage.getItem('egg_game_client_id');
      if (!stored) { stored = crypto.randomUUID(); localStorage.setItem('egg_game_client_id', stored); }
      return stored;
  }).current();

  const fetchState = async () => {
      try {
          const res = await fetch(`${API_URL}/api/state`);
          if (res.ok) {
              const data = await res.json();
              setServerState(prev => (data.lastUpdatedAt < prev.lastUpdatedAt && data.round === prev.round) ? prev : data);
          }
      } catch (e) {
          setServerState(prev => ({ ...prev, status: 'ERROR', announcement: e.message }));
      }
  };

  useEffect(() => {
      if (!connected) { fetchState(); pollingIntervalRef.current = setInterval(fetchState, 5000); }
      else { if (pollingIntervalRef.current) clearInterval(pollingIntervalRef.current); }
      return () => { if (pollingIntervalRef.current) clearInterval(pollingIntervalRef.current); };
  }, [connected]);

  const connect = useCallback(() => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.CONNECTING) return;
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({ type: "join", mode: "player", clientId, country: countryRef.current }));
        return;
    }
    const ws = new WebSocket(`${WS_URL}?mode=player`);
    wsRef.current = ws;
    ws.onopen = () => { setConnected(true); setError(null); ws.send(JSON.stringify({ type: "join", mode: "player", clientId, country: countryRef.current })); };
    ws.onmessage = (event) => {
      try {
        const msg = JSON.parse(event.data);
        switch (msg.type) {
            case 'join_ok': setRole(msg.role); setQueuePos(msg.queuePos); setError(null); break;
            case 'state': setServerState(prev => (msg.lastUpdatedAt < prev.lastUpdatedAt && msg.round === prev.round) ? prev : msg); break;
            case 'queue_update': setQueuePos(msg.queuePos); setEtaSec(msg.etaSec); break;
            case 'you_won': setWinningToken(msg.token); if (msg.startTime) setWinStartTime(msg.startTime); if (msg.prizeSecretUrl) setPrizeSecretImageUrl(msg.prizeSecretUrl); break;
            case 'invite_reward': setRewardEvent({ amount: msg.amount, msg: msg.msg, id: Date.now() }); break;
            case 'error': if (msg.code !== 'GAME_OVER') { if (msg.code === 'FULL' || msg.code === 'ROUND_NOT_STARTED') { setError(msg.code); ws.close(); } } break;
        }
      } catch (e) {}
    };
    ws.onclose = () => { setConnected(false); setRole(null); setQueuePos(null); };
    ws.onerror = () => ws.close();
  }, [clientId]);

  useEffect(() => {
    const interval = setInterval(() => {
        if (wsRef.current?.readyState === WebSocket.OPEN && clickAccumulator.current > 0) {
            wsRef.current.send(JSON.stringify({ type: 'click_delta', clientId, delta: clickAccumulator.current, atk: maxPowerInBatch.current, points: latestPoints.current, totalClicks: latestTotalClicks.current, country: countryRef.current, ts: Date.now() }));
            clickAccumulator.current = 0; maxPowerInBatch.current = 0;
        }
    }, 5000);
    return () => clearInterval(interval);
  }, [clientId]);

  const addClick = (power, country, currentPoints, totalClicks) => {
      clickAccumulator.current += power;
      if (power > maxPowerInBatch.current) maxPowerInBatch.current = power;
      latestPoints.current = currentPoints; latestTotalClicks.current = totalClicks;
      if (country) countryRef.current = country;
  };

  return { serverState, API_URL, error, connected, role, queuePos, etaSec, addClick, connect, clientId, winningToken, winStartTime, prizeSecretImageUrl, rewardEvent };
}
